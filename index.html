<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3-2G ãƒ–ãƒ©ã‚¶ãƒ¼ã‚º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            font-family: 'Arial', sans-serif;
        }

        #gameContainer {
            position: relative;
        }

        canvas {
            border: 3px solid #333;
            display: block;
            background: linear-gradient(to bottom, #5c9fd8 0%, #8fc9f5 100%);
        }

        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #titleScreen.hidden {
            display: none;
        }

        .title-logo {
            font-size: 72px;
            font-weight: bold;
            color: #fff;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            animation: titleBounce 2s ease-in-out infinite;
        }

        @keyframes titleBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .title-subtitle {
            font-size: 24px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 50px;
        }

        .start-btn {
            padding: 20px 60px;
            font-size: 28px;
            background: linear-gradient(to bottom, #4CAF50 0%, #45a049 100%);
            color: white;
            border: 4px solid #fff;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            font-weight: bold;
        }

        .start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
        }

        .start-btn:active {
            transform: scale(0.95);
        }

        .title-character {
            font-size: 48px;
            margin-top: 30px;
            animation: characterWalk 1s steps(2) infinite;
        }

        @keyframes characterWalk {
            0%, 100% { content: 'ğŸš¶'; }
            50% { content: 'ğŸš¶â€â™‚ï¸'; }
        }

        #gameOver, #gameClear {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px 60px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 4px solid #fff;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        #gameOver h1 {
            font-size: 48px;
            color: #ff4444;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #gameClear h1 {
            font-size: 48px;
            color: #44ff44;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .restart-btn {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .restart-btn:hover {
            background-color: #45a049;
        }

        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 250px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        #instructions h3 {
            margin-bottom: 10px;
            color: #333;
        }

        #instructions p {
            margin: 5px 0;
            color: #555;
        }

        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #ffd700;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
        }

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–Canvasè¨­å®š */
        #gameContainer {
            position: relative;
            max-width: 100%;
            max-height: 100vh;
        }

        canvas {
            max-width: 100%;
            max-height: 100vh;
            width: auto;
            height: auto;
            display: block;
            margin: 0 auto;
        }

        /* ãƒ¢ãƒã‚¤ãƒ«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            height: 200px;
            pointer-events: none;
            z-index: 1000;
        }

        #mobileControls.active {
            display: block;
        }

        .control-button {
            pointer-events: auto;
            position: absolute;
            background: rgba(255, 255, 255, 0.4);
            border: 3px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #333;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            transition: all 0.1s ease;
        }

        .control-button:active {
            background: rgba(255, 255, 255, 0.7);
            transform: scale(0.95);
        }

        /* D-pad ã‚³ãƒ³ãƒ†ãƒŠ */
        .dpad-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 180px;
            height: 180px;
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 0;
        }

        .dpad-left {
            grid-column: 1;
            grid-row: 2;
            width: 70px;
            height: 70px;
            font-size: 32px;
        }

        .dpad-right {
            grid-column: 3;
            grid-row: 2;
            width: 70px;
            height: 70px;
            font-size: 32px;
        }

        /* ã‚¸ãƒ£ãƒ³ãƒ—ãƒœã‚¿ãƒ³ */
        .jump-button {
            bottom: 40px;
            right: 40px;
            width: 90px;
            height: 90px;
            font-size: 16px;
            background: rgba(76, 175, 80, 0.5);
            border-color: rgba(76, 175, 80, 0.8);
        }

        .jump-button:active {
            background: rgba(76, 175, 80, 0.8);
        }

        /* æ¨ªç”»é¢æ¨å¥¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
        #orientationWarning {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 2000;
            max-width: 80%;
        }

        #orientationWarning h2 {
            margin-bottom: 15px;
            font-size: 24px;
        }

        #orientationWarning p {
            font-size: 16px;
            line-height: 1.5;
        }

        /* ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¯ã‚¨ãƒª */
        @media screen and (max-width: 768px) {
            body {
                min-height: 100vh;
                min-height: -webkit-fill-available;
            }

            #instructions {
                font-size: 12px;
                padding: 10px;
                max-width: 200px;
            }

            #score {
                font-size: 16px;
                padding: 8px 15px;
            }
        }

        /* ç¸¦ç”»é¢ã®å ´åˆ */
        @media screen and (max-width: 768px) and (orientation: portrait) {
            #orientationWarning {
                display: block;
            }

            .dpad-container {
                bottom: 15px;
                left: 15px;
                width: 150px;
                height: 150px;
                grid-template-columns: repeat(3, 50px);
                grid-template-rows: repeat(3, 50px);
            }

            .dpad-left, .dpad-right {
                width: 60px;
                height: 60px;
                font-size: 28px;
            }

            .jump-button {
                bottom: 30px;
                right: 30px;
                width: 80px;
                height: 80px;
                font-size: 14px;
            }
        }

        /* æ¨ªç”»é¢ã®å ´åˆ */
        @media screen and (max-width: 768px) and (orientation: landscape) {
            #orientationWarning {
                display: none;
            }
        }

        /* ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹ä»¥å¤–ã§ã¯éè¡¨ç¤º */
        @media (hover: hover) and (pointer: fine) {
            #mobileControls {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="600"></canvas>

        <!-- ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ -->
        <div id="titleScreen">
            <div class="title-logo">3-2G ãƒ–ãƒ©ã‚¶ãƒ¼ã‚º</div>
            <div class="title-subtitle">ï½ å†’é™ºã®å§‹ã¾ã‚Š ï½</div>
            <button class="start-btn" onclick="startGame()">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
            <div class="title-character">ğŸ‘¤</div>
        </div>

        <div id="instructions">
            <h3>æ“ä½œæ–¹æ³•</h3>
            <p>â† â†’ : ç§»å‹•</p>
            <p>ã‚¹ãƒšãƒ¼ã‚¹ : ã‚¸ãƒ£ãƒ³ãƒ—</p>
            <p>ãƒ»æ•µã‚’ä¸Šã‹ã‚‰è¸ã‚“ã§å€’ãã†ï¼</p>
            <p>ãƒ»?ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ GET</p>
            <p>ãƒ»ç©´ã«è½ã¡ãªã„ã‚ˆã†ã«æ³¨æ„ï¼</p>
            <p>ãƒ»<strong>ãƒœã‚¹ã«æŒ‘æˆ¦</strong>ã—ã¦æ——ã«åˆ°é”ï¼</p>
        </div>

        <div id="score">
            ã‚¹ã‚³ã‚¢: <span id="scoreValue">0</span>
        </div>

        <div id="gameOver">
            <h1>GAME OVER</h1>
            <p id="gameOverReason">ã‚„ã‚‰ã‚Œã¾ã—ãŸ</p>
            <button class="restart-btn" onclick="restartGame()">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
        </div>

        <div id="gameClear">
            <h1>CLEAR!</h1>
            <p>ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ãŠã‚ã§ã¨ã†ï¼</p>
            <p>ã‚¹ã‚³ã‚¢: <span id="finalScore">0</span></p>
            <button class="restart-btn" onclick="restartGame()">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
        </div>

        <!-- ãƒ¢ãƒã‚¤ãƒ«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
        <div id="mobileControls">
            <div class="dpad-container">
                <div class="control-button dpad-left" data-key="left">â—</div>
                <div class="control-button dpad-right" data-key="right">â–·</div>
            </div>
            <div class="control-button jump-button" data-key="jump">JUMP</div>
        </div>

        <!-- æ¨ªç”»é¢æ¨å¥¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ -->
        <div id="orientationWarning">
            <h2>ğŸ“± æ¨ªç”»é¢æ¨å¥¨</h2>
            <p>ã‚ˆã‚Šå¿«é©ã«ãƒ—ãƒ¬ã‚¤ã™ã‚‹ã«ã¯<br>ãƒ‡ãƒã‚¤ã‚¹ã‚’æ¨ªå‘ãã«ã—ã¦ãã ã•ã„</p>
        </div>
    </div>

    <script>
        // Canvasè¨­å®š
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ã‚²ãƒ¼ãƒ å®šæ•°
        const GRAVITY = 0.6;
        const JUMP_POWER = -14;
        const MOVE_SPEED = 5;
        const GROUND_Y = canvas.height - 80;
        const GROUND_HEIGHT = 80;

        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
        let gameState = 'title'; // 'title', 'playing', 'falling', 'hit', 'gameOver', 'clear'
        let gameOverReason = ''; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã®ç†ç”±ã‚’ä¿å­˜
        let cameraX = 0; // ã‚«ãƒ¡ãƒ©ã®Xåº§æ¨™ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç”¨ï¼‰
        let animationFrame = 0; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
        let score = 0; // ã‚¹ã‚³ã‚¢

        // ã‚­ãƒ¼å…¥åŠ›ç®¡ç†
        const keys = {
            left: false,
            right: false,
            space: false
        };

        // ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œå¤‰æ•°
        let isTouchDevice = false;
        let canvasScale = 1;
        let touchState = {
            left: { active: false, touchId: null },
            right: { active: false, touchId: null },
            jump: { active: false, touchId: null }
        };

        // ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹æ¤œå‡º
        function detectTouchDevice() {
            return ('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0) ||
                   (navigator.msMaxTouchPoints > 0);
        }

        // Canvasæ‹¡å¤§ç‡ã‚’è¨ˆç®—ã—ã¦é©ç”¨
        function updateCanvasScale() {
            const container = document.getElementById('gameContainer');
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒï¼ˆ2:1ï¼‰
            const canvasRatio = canvas.width / canvas.height;
            const windowRatio = windowWidth / windowHeight;

            let newWidth, newHeight;

            if (windowRatio > canvasRatio) {
                // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æ–¹ãŒæ¨ªé•·
                newHeight = windowHeight;
                newWidth = newHeight * canvasRatio;
            } else {
                // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æ–¹ãŒç¸¦é•·
                newWidth = windowWidth;
                newHeight = newWidth / canvasRatio;
            }

            // ãƒ¢ãƒã‚¤ãƒ«ã®å ´åˆã¯å°‘ã—å°ã•ãã—ã¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¹ãƒšãƒ¼ã‚¹ã‚’ç¢ºä¿
            if (isTouchDevice && window.innerWidth <= 768) {
                newHeight = Math.min(newHeight, windowHeight - 220);
                newWidth = newHeight * canvasRatio;
            }

            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';

            canvasScale = newWidth / canvas.width;
        }

        // ãƒ¢ãƒã‚¤ãƒ«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®åˆæœŸåŒ–
        function initMobileControls() {
            isTouchDevice = detectTouchDevice();

            if (isTouchDevice) {
                const mobileControls = document.getElementById('mobileControls');
                mobileControls.classList.add('active');
                setupTouchControls();

                // ç”»é¢ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.width = '100%';
                document.body.style.height = '100%';

                // ã‚¿ãƒƒãƒãƒ ãƒ¼ãƒ–ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢
                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                }, { passive: false });
            }

            updateCanvasScale();
        }

        // ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«è¨­å®š
        function setupTouchControls() {
            const leftBtn = document.querySelector('.dpad-left');
            const rightBtn = document.querySelector('.dpad-right');
            const jumpBtn = document.querySelector('.jump-button');

            // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ç„¡åŠ¹åŒ–
            [leftBtn, rightBtn, jumpBtn].forEach(btn => {
                btn.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            });

            // å·¦ãƒœã‚¿ãƒ³
            setupButton(leftBtn, 'left');

            // å³ãƒœã‚¿ãƒ³
            setupButton(rightBtn, 'right');

            // ã‚¸ãƒ£ãƒ³ãƒ—ãƒœã‚¿ãƒ³
            setupButton(jumpBtn, 'jump');
        }

        function setupButton(button, keyType) {
            // ã‚¿ãƒƒãƒé–‹å§‹
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();

                const touch = e.changedTouches[0];
                touchState[keyType].active = true;
                touchState[keyType].touchId = touch.identifier;

                // keys ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ›´æ–°
                if (keyType === 'left') {
                    keys.left = true;
                } else if (keyType === 'right') {
                    keys.right = true;
                } else if (keyType === 'jump') {
                    keys.space = true;
                }

                // è§¦è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                if (navigator.vibrate) {
                    navigator.vibrate(10);
                }
            }, { passive: false });

            // ã‚¿ãƒƒãƒçµ‚äº†
            button.addEventListener('touchend', (e) => {
                e.preventDefault();

                const touch = e.changedTouches[0];
                if (touchState[keyType].touchId === touch.identifier) {
                    touchState[keyType].active = false;
                    touchState[keyType].touchId = null;

                    // keys ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ›´æ–°
                    if (keyType === 'left') {
                        keys.left = false;
                    } else if (keyType === 'right') {
                        keys.right = false;
                    } else if (keyType === 'jump') {
                        keys.space = false;
                    }
                }
            }, { passive: false });

            // ã‚¿ãƒƒãƒã‚­ãƒ£ãƒ³ã‚»ãƒ«
            button.addEventListener('touchcancel', (e) => {
                e.preventDefault();

                const touch = e.changedTouches[0];
                if (touchState[keyType].touchId === touch.identifier) {
                    touchState[keyType].active = false;
                    touchState[keyType].touchId = null;

                    // keys ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ›´æ–°
                    if (keyType === 'left') {
                        keys.left = false;
                    } else if (keyType === 'right') {
                        keys.right = false;
                    } else if (keyType === 'jump') {
                        keys.space = false;
                    }
                }
            }, { passive: false });
        }

        // ã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒ©ã‚¹
        class Item {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'coin', 'mushroom', 'star'
                this.width = 30;
                this.height = 30;
                this.velocityY = -8; // å‡ºç¾æ™‚ã®ä¸Šæ˜‡
                this.velocityX = 0;
                this.isCollected = false;
                this.isEmerging = true; // å‡ºç¾ä¸­ãƒ•ãƒ©ã‚°
                this.emergeStartY = y;
            }

            update() {
                if (this.isCollected) return;

                if (this.isEmerging) {
                    // ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰å‡ºç¾ä¸­
                    this.y += this.velocityY;
                    if (this.y <= this.emergeStartY - 40) {
                        this.isEmerging = false;
                        this.velocityY = 0;
                        if (this.type === 'mushroom') {
                            this.velocityX = 2; // ã‚­ãƒã‚³ã¯æ¨ªã«å‹•ã
                        }
                    }
                } else {
                    if (this.type === 'coin') {
                        // ã‚³ã‚¤ãƒ³ã¯æµ®éŠ
                        this.y += Math.sin(animationFrame * 0.1) * 0.5;
                    } else if (this.type === 'mushroom') {
                        // ã‚­ãƒã‚³ã¯æ¨ªç§»å‹•ï¼‹é‡åŠ›
                        this.x += this.velocityX;
                        this.velocityY += GRAVITY;
                        this.y += this.velocityY;

                        // åœ°é¢ã¨ã®è¡çª
                        if (this.y + this.height >= GROUND_Y) {
                            this.y = GROUND_Y - this.height;
                            this.velocityY = 0;
                        }

                        // å£ã§åè»¢
                        if (this.x < 0 || this.x > 3000) {
                            this.velocityX *= -1;
                        }
                    } else if (this.type === 'star') {
                        // ã‚¹ã‚¿ãƒ¼ã¯è·³ã­ã‚‹
                        this.x += this.velocityX;
                        this.velocityY += GRAVITY;
                        this.y += this.velocityY;

                        if (this.y + this.height >= GROUND_Y) {
                            this.y = GROUND_Y - this.height;
                            this.velocityY = -10;
                        }
                    }
                }
            }

            draw() {
                if (this.isCollected) return;

                const screenX = this.x - cameraX;

                if (this.type === 'coin') {
                    // ã‚³ã‚¤ãƒ³ï¼ˆé‡‘è‰²ï¼‰
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, this.y + this.height / 2, 12, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#ff8c00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, this.y + this.height / 2, 12, 0, Math.PI * 2);
                    ctx.stroke();

                    // è¼ã
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2 - 4, this.y + this.height / 2 - 4, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'mushroom') {
                    // ã‚­ãƒã‚³ï¼ˆèµ¤ã¨ç™½ï¼‰
                    // å‚˜
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, this.y + 12, 14, Math.PI, 0, false);
                    ctx.fill();

                    // ç™½ã„æ–‘ç‚¹
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2 - 6, this.y + 8, 4, 0, Math.PI * 2);
                    ctx.arc(screenX + this.width / 2 + 6, this.y + 8, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // æŸ„
                    ctx.fillStyle = '#ecf0f1';
                    ctx.fillRect(screenX + this.width / 2 - 6, this.y + 12, 12, 16);

                    // ç›®
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2 - 4, this.y + 18, 2, 0, Math.PI * 2);
                    ctx.arc(screenX + this.width / 2 + 4, this.y + 18, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'star') {
                    // ã‚¹ã‚¿ãƒ¼ï¼ˆè™¹è‰²ï¼‰
                    const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
                    const colorIndex = Math.floor(animationFrame / 5) % colors.length;
                    ctx.fillStyle = colors[colorIndex];

                    // æ˜Ÿå½¢
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                        const x = screenX + this.width / 2 + Math.cos(angle) * 14;
                        const y = this.y + this.height / 2 + Math.sin(angle) * 14;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }

            collect(player) {
                this.isCollected = true;
                if (this.type === 'coin') {
                    score += 100;
                } else if (this.type === 'mushroom') {
                    score += 500;
                    player.powerUp(); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—
                } else if (this.type === 'star') {
                    score += 1000;
                    // ç„¡æ•µçŠ¶æ…‹ãªã©
                }
                updateScore();
            }
        }

        // ãƒ–ãƒ­ãƒƒã‚¯ã‚¯ãƒ©ã‚¹
        class Block {
            constructor(x, y, type = 'brick', itemType = null) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.type = type; // 'brick', 'question', 'stone'
                this.isHit = false; // ãƒãƒ†ãƒŠãƒ–ãƒ­ãƒƒã‚¯ãŒå©ã‹ã‚ŒãŸã‹
                this.itemType = itemType; // 'coin', 'mushroom', 'star', null
                this.bounceOffset = 0; // å©ã‹ã‚ŒãŸæ™‚ã®ãƒã‚¦ãƒ³ãƒ‰
            }

            draw() {
                const screenX = this.x - cameraX;
                const drawY = this.y + this.bounceOffset;

                if (this.type === 'brick') {
                    // ãƒ¬ãƒ³ã‚¬ãƒ–ãƒ­ãƒƒã‚¯
                    ctx.fillStyle = '#c95a27';
                    ctx.fillRect(screenX, drawY, this.width, this.height);

                    // ãƒ¬ãƒ³ã‚¬æ¨¡æ§˜
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, drawY, this.width, this.height);
                    ctx.beginPath();
                    ctx.moveTo(screenX + this.width / 2, drawY);
                    ctx.lineTo(screenX + this.width / 2, drawY + this.height);
                    ctx.stroke();
                } else if (this.type === 'question') {
                    // ãƒãƒ†ãƒŠãƒ–ãƒ­ãƒƒã‚¯
                    if (this.isHit) {
                        ctx.fillStyle = '#8B7355';
                    } else {
                        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
                        const brightness = 180 + Math.sin(animationFrame * 0.1) * 20;
                        ctx.fillStyle = `rgb(${brightness}, ${brightness - 20}, 96)`;
                    }
                    ctx.fillRect(screenX, drawY, this.width, this.height);

                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, drawY, this.width, this.height);

                    if (!this.isHit) {
                        // ï¼Ÿãƒãƒ¼ã‚¯ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                        const offsetY = Math.sin(animationFrame * 0.1) * 2;
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 28px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('?', screenX + this.width / 2, drawY + this.height / 2 + offsetY);
                    }
                } else if (this.type === 'stone') {
                    // çŸ³ãƒ–ãƒ­ãƒƒã‚¯
                    ctx.fillStyle = '#888';
                    ctx.fillRect(screenX, drawY, this.width, this.height);

                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, drawY, this.width, this.height);
                }

                // ãƒã‚¦ãƒ³ãƒ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
                if (this.bounceOffset < 0) {
                    this.bounceOffset += 2;
                    if (this.bounceOffset > 0) this.bounceOffset = 0;
                }
            }

            hit() {
                if (this.type === 'question' && !this.isHit) {
                    this.isHit = true;
                    this.bounceOffset = -10; // ãƒã‚¦ãƒ³ãƒ‰åŠ¹æœ

                    // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç”Ÿæˆ
                    if (this.itemType) {
                        const item = new Item(this.x + 5, this.y, this.itemType);
                        items.push(item);
                    }
                }
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
        }

        // ãƒ‘ã‚¤ãƒ—ï¼ˆãƒ‰ã‚«ãƒ³ï¼‰ã‚¯ãƒ©ã‚¹
        class Pipe {
            constructor(x, height = 80) {
                this.x = x;
                this.height = height;
                this.width = 60;
                this.y = GROUND_Y - this.height;
            }

            draw() {
                const screenX = this.x - cameraX;

                // ãƒ‘ã‚¤ãƒ—æœ¬ä½“ï¼ˆç·‘ï¼‰
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(screenX, this.y, this.width, this.height);

                // ãƒ‘ã‚¤ãƒ—ã®ç¸å–ã‚Š
                ctx.strokeStyle = '#27ae60';
                ctx.lineWidth = 3;
                ctx.strokeRect(screenX, this.y, this.width, this.height);

                // ãƒ‘ã‚¤ãƒ—ã®å£
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(screenX - 5, this.y - 10, this.width + 10, 15);
                ctx.strokeStyle = '#1e8449';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX - 5, this.y - 10, this.width + 10, 15);

                // å½±ï¼ˆç«‹ä½“æ„Ÿï¼‰
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(screenX + this.width / 2, this.y, this.width / 2, this.height);

                // å†…å´ã®å½±
                ctx.fillStyle = '#000';
                ctx.fillRect(screenX + 10, this.y - 8, this.width - 20, 10);
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
        }

        // ç©´ã‚¯ãƒ©ã‚¹
        class Pit {
            constructor(x, width) {
                this.x = x;
                this.width = width;
                this.y = GROUND_Y;
            }

            draw() {
                const screenX = this.x - cameraX;

                // ç©´ï¼ˆé»’ï¼‰
                ctx.fillStyle = '#000';
                ctx.fillRect(screenX, this.y, this.width, GROUND_HEIGHT);
            }

            checkFall(player) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®70%ä»¥ä¸ŠãŒç©´ã®ä¸Šã«ã‚ã‚‹å ´åˆã®ã¿è½ä¸‹
                const playerLeft = player.x + player.width * 0.15;
                const playerRight = player.x + player.width * 0.85;
                return playerLeft > this.x &&
                       playerRight < this.x + this.width &&
                       player.y + player.height >= GROUND_Y;
            }
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹ï¼ˆ3-2Gæ–‡å­—ã‚­ãƒ£ãƒ©ï¼‰
        class Player {
            constructor() {
                this.normalWidth = 50;
                this.normalHeight = 40;
                this.powerWidth = 100;
                this.powerHeight = 80;

                this.width = this.normalWidth;
                this.height = this.normalHeight;
                this.x = 100;
                this.y = GROUND_Y - this.height;
                this.velocityX = 0;
                this.velocityY = 0;
                this.isJumping = false;
                this.isOnGround = false;
                this.direction = 1; // 1: å³å‘ã, -1: å·¦å‘ã
                this.isFalling = false; // ç©´ã«è½ã¡ã¦ã„ã‚‹ã‹
                this.fallRotation = 0; // è½ä¸‹æ™‚ã®å›è»¢
                this.isPoweredUp = false; // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—çŠ¶æ…‹
                this.powerUpAnimation = 0; // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
                this.isHit = false; // æ•µã«å½“ãŸã£ãŸçŠ¶æ…‹
                this.hitKnockbackX = 0; // ãƒãƒƒã‚¯ãƒãƒƒã‚¯æ–¹å‘
                this.invincible = false; // ç„¡æ•µçŠ¶æ…‹
                this.invincibleTimer = 0; // ç„¡æ•µæ™‚é–“ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
            }

            update(blocks, pipes) {
                // ç„¡æ•µæ™‚é–“ã®æ›´æ–°
                if (this.invincibleTimer > 0) {
                    this.invincibleTimer--;
                    if (this.invincibleTimer === 0) {
                        this.invincible = false;
                    }
                }

                // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.powerUpAnimation > 0) {
                    this.powerUpAnimation--;
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã¯ã‚µã‚¤ã‚ºãŒå¤‰åŒ–
                    const progress = (30 - this.powerUpAnimation) / 30;
                    if (this.isPoweredUp) {
                        this.width = this.normalWidth + (this.powerWidth - this.normalWidth) * progress;
                        this.height = this.normalHeight + (this.powerHeight - this.normalHeight) * progress;
                    } else {
                        this.width = this.powerWidth - (this.powerWidth - this.normalWidth) * progress;
                        this.height = this.powerHeight - (this.powerHeight - this.normalHeight) * progress;
                    }
                    this.y = GROUND_Y - this.height;
                }

                if (this.isFalling) {
                    // ç©´ã«è½ä¸‹ä¸­ï¼ˆå›è»¢ãªã—ã€ãã®ã¾ã¾è½ã¡ã‚‹ï¼‰
                    this.velocityY += GRAVITY * 1.5;
                    this.y += this.velocityY;

                    // ç”»é¢å¤–ã«å‡ºãŸã‚‰ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
                    if (this.y > canvas.height + 100) {
                        gameState = 'gameOver';
                        document.getElementById('gameOverReason').textContent = 'ç©´ã«è½ã¡ã¾ã—ãŸ';
                        document.getElementById('gameOver').style.display = 'block';
                    }
                    return;
                }

                if (this.isHit) {
                    // æ•µã«å½“ãŸã£ãŸæ™‚ã®ãƒãƒƒã‚¯ãƒãƒƒã‚¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    this.x += this.hitKnockbackX;
                    this.velocityY += GRAVITY * 1.5;
                    this.y += this.velocityY;
                    this.fallRotation += 0.15;
                    return;
                }

                // å·¦å³ç§»å‹•
                if (keys.left) {
                    this.velocityX = -MOVE_SPEED;
                    this.direction = -1;
                } else if (keys.right) {
                    this.velocityX = MOVE_SPEED;
                    this.direction = 1;
                } else {
                    this.velocityX = 0;
                }

                // ã‚¸ãƒ£ãƒ³ãƒ—
                if (keys.space && this.isOnGround && !this.isJumping) {
                    this.velocityY = JUMP_POWER;
                    this.isJumping = true;
                    this.isOnGround = false;
                }

                // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ãŒé›¢ã•ã‚ŒãŸã‚‰ã‚¸ãƒ£ãƒ³ãƒ—ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
                if (!keys.space) {
                    this.isJumping = false;
                }

                // é‡åŠ›é©ç”¨
                this.velocityY += GRAVITY;

                // ä½ç½®æ›´æ–°ï¼ˆXè»¸ï¼‰
                this.x += this.velocityX;

                // ãƒ‘ã‚¤ãƒ—ã¨ã®è¡çªåˆ¤å®šï¼ˆæ¨ªï¼‰
                pipes.forEach(pipe => {
                    const pipeRect = pipe.getRect();
                    const playerRect = this.getRect();

                    if (this.checkCollision(playerRect, pipeRect)) {
                        if (this.velocityX > 0) {
                            this.x = pipeRect.x - this.width;
                        } else if (this.velocityX < 0) {
                            this.x = pipeRect.x + pipeRect.width;
                        }
                    }
                });

                // ãƒ–ãƒ­ãƒƒã‚¯ã¨ã®è¡çªåˆ¤å®šï¼ˆæ¨ªï¼‰
                blocks.forEach(block => {
                    const blockRect = block.getRect();
                    const playerRect = this.getRect();

                    if (this.checkCollision(playerRect, blockRect)) {
                        if (this.velocityX > 0) {
                            this.x = blockRect.x - this.width;
                        } else if (this.velocityX < 0) {
                            this.x = blockRect.x + blockRect.width;
                        }
                    }
                });

                // ç”»é¢å·¦ç«¯ã®åˆ¶é™
                if (this.x < 0) {
                    this.x = 0;
                }

                // ä½ç½®æ›´æ–°ï¼ˆYè»¸ï¼‰
                this.y += this.velocityY;

                // åœ°é¢ã¨ã®è¡çªåˆ¤å®š
                this.isOnGround = false;
                if (this.y + this.height >= GROUND_Y) {
                    this.y = GROUND_Y - this.height;
                    this.velocityY = 0;
                    this.isOnGround = true;
                }

                // ãƒ–ãƒ­ãƒƒã‚¯ã¨ã®è¡çªåˆ¤å®šï¼ˆä¸Šä¸‹ï¼‰
                blocks.forEach(block => {
                    const blockRect = block.getRect();
                    const playerRect = this.getRect();

                    if (this.checkCollision(playerRect, blockRect)) {
                        if (this.velocityY > 0) {
                            // ä¸‹ã«ç§»å‹•ä¸­ï¼ˆãƒ–ãƒ­ãƒƒã‚¯ã®ä¸Šã«ç€åœ°ï¼‰
                            this.y = blockRect.y - this.height;
                            this.velocityY = 0;
                            this.isOnGround = true;
                        } else if (this.velocityY < 0) {
                            // ä¸Šã«ç§»å‹•ä¸­ï¼ˆãƒ–ãƒ­ãƒƒã‚¯ã®ä¸‹ã«é ­ã‚’ã¶ã¤ã‘ã‚‹ï¼‰
                            this.y = blockRect.y + blockRect.height;
                            this.velocityY = 0;
                            block.hit();
                        }
                    }
                });

                // ãƒ‘ã‚¤ãƒ—ã¨ã®è¡çªåˆ¤å®šï¼ˆä¸Šï¼‰
                pipes.forEach(pipe => {
                    const pipeRect = pipe.getRect();
                    const playerRect = this.getRect();

                    if (this.checkCollision(playerRect, pipeRect)) {
                        if (this.velocityY > 0) {
                            this.y = pipeRect.y - this.height;
                            this.velocityY = 0;
                            this.isOnGround = true;
                        }
                    }
                });

                // ã‚«ãƒ¡ãƒ©è¿½å¾“ï¼ˆå·¦å³ä¸¡æ–¹å‘ã«å¯¾å¿œï¼‰
                const playerScreenX = this.x - cameraX;
                const centerX = canvas.width / 2;
                const deadZone = 100; // ã‚«ãƒ¡ãƒ©ãŒå‹•ãå§‹ã‚ã‚‹ã¾ã§ã®ç¯„å›²

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç”»é¢ä¸­å¤®ã‚ˆã‚Šå³ã«ã„ã‚‹å ´åˆ
                if (playerScreenX > centerX + deadZone) {
                    cameraX = this.x - centerX - deadZone;
                }
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç”»é¢ä¸­å¤®ã‚ˆã‚Šå·¦ã«ã„ã‚‹å ´åˆ
                else if (playerScreenX < centerX - deadZone) {
                    cameraX = this.x - centerX + deadZone;
                }

                // ã‚«ãƒ¡ãƒ©ã®å·¦ç«¯åˆ¶é™
                if (cameraX < 0) {
                    cameraX = 0;
                }
            }

            draw() {
                const screenX = this.x - cameraX;

                // ç„¡æ•µä¸­ã¯ç‚¹æ»…ã•ã›ã‚‹
                if (this.invincible && Math.floor(this.invincibleTimer / 5) % 2 === 0) {
                    return; // ç‚¹æ»…ã®ãŸã‚æç”»ã‚’ã‚¹ã‚­ãƒƒãƒ—
                }

                ctx.save();

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
                const walkCycle = Math.sin(animationFrame * 0.3);
                const legOffset = this.velocityX !== 0 ? walkCycle * 3 : 0;
                const armSwing = this.velocityX !== 0 ? walkCycle * 4 : 0;
                const isJumpPose = !this.isOnGround;

                // ã‚µã‚¤ã‚ºã«å¿œã˜ãŸã‚¹ã‚±ãƒ¼ãƒ«
                const scale = this.width / this.normalWidth;
                const baseY = this.y + this.height;

                // === ã€Œ3-2Gã€ç¸¦æ›¸ãæ–‡å­—æœ¬ä½“ ===
                // æ–‡å­—ã‚’ç¸¦ã«é…ç½®
                const chars = ['3', '-', '2', 'G'];
                const charHeight = this.height / chars.length;
                const fontSize = Math.floor(charHeight * 0.9); // ã‚ˆã‚Šå¤§ãã
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // å„æ–‡å­—ã‚’æç”»
                chars.forEach((char, index) => {
                    const charY = this.y + charHeight * index + charHeight / 2;

                    // æ–‡å­—ã®å½±ï¼ˆã‚ˆã‚Šæ¿ƒãï¼‰
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillText(char, screenX + this.width / 2 + 3 * scale, charY + 3 * scale);

                    // æ–‡å­—ã®ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ï¼ˆã‚ˆã‚Šå¤ªãã€æ¿ƒã„è‰²ï¼‰
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 6 * scale;
                    ctx.lineJoin = 'round';
                    ctx.strokeText(char, screenX + this.width / 2, charY);

                    // æ–‡å­—æœ¬ä½“ï¼ˆã‚ˆã‚Šæ˜ã‚‹ã„è‰²ï¼‰
                    ctx.fillStyle = '#FFD700'; // é‡‘è‰²ã§ç›®ç«‹ã¤ã‚ˆã†ã«
                    ctx.fillText(char, screenX + this.width / 2, charY);
                });

                // === è¶³ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ï¼‰ ===
                const legWidth = 4 * scale;
                const legHeight = 6 * scale; // 8â†’6ã«çŸ­ç¸®
                const footSize = 6 * scale;
                const legStartY = baseY - legHeight; // è¶³ã‚’ä½“ã®å†…å´ã‹ã‚‰æç”»

                ctx.fillStyle = '#2c3e50';

                if (isJumpPose) {
                    // ã‚¸ãƒ£ãƒ³ãƒ—æ™‚ï¼šè¶³ã‚’æƒãˆã‚‹
                    ctx.fillRect(screenX + this.width * 0.35, legStartY, legWidth, legHeight);
                    ctx.fillRect(screenX + this.width * 0.6, legStartY, legWidth, legHeight);

                    // é´
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(screenX + this.width * 0.35 - 2, baseY, footSize, 2 * scale);
                    ctx.fillRect(screenX + this.width * 0.6 - 2, baseY, footSize, 2 * scale);
                } else {
                    // æ­©è¡Œæ™‚ï¼šè¶³ã‚’å‹•ã‹ã™
                    ctx.fillRect(screenX + this.width * 0.35, legStartY + legOffset, legWidth, legHeight);
                    ctx.fillRect(screenX + this.width * 0.6, legStartY - legOffset, legWidth, legHeight);

                    // é´
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(screenX + this.width * 0.35 - 2, baseY + legOffset, footSize, 2 * scale);
                    ctx.fillRect(screenX + this.width * 0.6 - 2, baseY - legOffset, footSize, 2 * scale);
                }


                ctx.restore();
            }

            startFalling() {
                this.isFalling = true;
                this.velocityY = -8; // å°‘ã—ä¸Šã«è·³ã­ã‚‹
            }

            startHitAnimation(enemyX) {
                this.isHit = true;
                this.velocityY = -10; // ä¸Šã«è·³ã­ã‚‹
                // æ•µã®ä½ç½®ã«å¿œã˜ã¦ãƒãƒƒã‚¯ãƒãƒƒã‚¯æ–¹å‘ã‚’æ±ºå®š
                this.hitKnockbackX = this.x < enemyX ? -3 : 3;
            }

            powerUp() {
                if (!this.isPoweredUp) {
                    this.isPoweredUp = true;
                    this.powerUpAnimation = 30; // 30ãƒ•ãƒ¬ãƒ¼ãƒ ã§ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                }
            }

            powerDown() {
                if (this.isPoweredUp) {
                    this.isPoweredUp = false;
                    this.powerUpAnimation = 30;
                    this.invincible = true;
                    this.invincibleTimer = 120; // 2ç§’é–“ç„¡æ•µï¼ˆ60fps x 2ï¼‰
                }
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }

            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
        }

        // ãƒœã‚¹ã‚¯ãƒ©ã‚¹
        class Boss {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 80;
                this.height = 80;
                this.velocityX = -3;
                this.velocityY = 0;
                this.isAlive = true;
                this.maxHp = 5;
                this.hp = this.maxHp;
                this.isJumping = false;
                this.jumpTimer = 0;
                this.hitFlash = 0; // ãƒ€ãƒ¡ãƒ¼ã‚¸ç‚¹æ»…ç”¨
            }

            update(blocks, pipes, pits) {
                if (!this.isAlive) return;

                // ç©´ã®æ‰‹å‰ã§ãƒã‚§ãƒƒã‚¯
                let nearPit = false;
                if (pits) {
                    pits.forEach(pit => {
                        const checkDistance = 50;
                        if (this.velocityX > 0) {
                            if (this.x + this.width + checkDistance > pit.x && this.x < pit.x) {
                                nearPit = true;
                            }
                        } else {
                            if (this.x - checkDistance < pit.x + pit.width && this.x > pit.x + pit.width) {
                                nearPit = true;
                            }
                        }
                    });
                }

                if (nearPit) {
                    this.velocityX *= -1;
                }

                // å·¦å³ç§»å‹•
                this.x += this.velocityX;

                // ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆå®šæœŸçš„ã«ï¼‰
                this.jumpTimer++;
                if (this.jumpTimer > 120 && !this.isJumping) {
                    this.velocityY = -12;
                    this.isJumping = true;
                    this.jumpTimer = 0;
                }

                // é‡åŠ›
                this.velocityY += GRAVITY;
                this.y += this.velocityY;

                // åœ°é¢ã¨ã®è¡çª
                if (this.y + this.height >= GROUND_Y) {
                    this.y = GROUND_Y - this.height;
                    this.velocityY = 0;
                    this.isJumping = false;
                }

                // ãƒ–ãƒ­ãƒƒã‚¯ã¨ã®è¡çª
                blocks.forEach(block => {
                    const blockRect = block.getRect();
                    const bossRect = this.getRect();
                    if (this.checkCollision(bossRect, blockRect)) {
                        if (this.y + this.height <= blockRect.y + 10) {
                            this.y = blockRect.y - this.height;
                            this.velocityY = 0;
                            this.isJumping = false;
                        } else {
                            this.velocityX *= -1;
                        }
                    }
                });

                // ãƒ‘ã‚¤ãƒ—ã¨ã®è¡çª
                pipes.forEach(pipe => {
                    const pipeRect = pipe.getRect();
                    const bossRect = this.getRect();
                    if (this.checkCollision(bossRect, pipeRect)) {
                        this.velocityX *= -1;
                    }
                });

                // ç§»å‹•ç¯„å›²åˆ¶é™ï¼ˆã‚´ãƒ¼ãƒ«å‘¨è¾ºï¼‰
                if (this.x < 4000 || this.x > 4400) {
                    this.velocityX *= -1;
                }

                // ãƒ€ãƒ¡ãƒ¼ã‚¸ç‚¹æ»…
                if (this.hitFlash > 0) {
                    this.hitFlash--;
                }
            }

            draw() {
                if (!this.isAlive) return;

                const screenX = this.x - cameraX;
                const walkFrame = Math.floor(animationFrame / 10) % 2;

                // ãƒ€ãƒ¡ãƒ¼ã‚¸ç‚¹æ»…
                if (this.hitFlash > 0 && Math.floor(this.hitFlash / 5) % 2 === 0) {
                    return; // ç‚¹æ»…ã•ã›ã‚‹ãŸã‚ã«ä¸€æ™‚çš„ã«éè¡¨ç¤º
                }

                // å½±
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, GROUND_Y + 2, this.width / 2, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // ä½“ï¼ˆå·¨å¤§ãªãã®ã“ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ï¼‰
                // ä½“ã®éƒ¨åˆ†
                ctx.fillStyle = '#8B0000'; // ãƒ€ãƒ¼ã‚¯ãƒ¬ãƒƒãƒ‰
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, this.y + 40, 35, 30, 0, 0, Math.PI * 2);
                ctx.fill();

                // å‚˜ã®éƒ¨åˆ†ï¼ˆèµ¤ã¨é»’ã®ãƒ‰ãƒƒãƒˆï¼‰
                ctx.fillStyle = '#DC143C'; // ã‚¯ãƒªãƒ ã‚¾ãƒ³
                ctx.beginPath();
                ctx.arc(screenX + 15, this.y + 15, 8, 0, Math.PI * 2);
                ctx.arc(screenX + 40, this.y + 10, 10, 0, Math.PI * 2);
                ctx.arc(screenX + 65, this.y + 15, 8, 0, Math.PI * 2);
                ctx.fill();

                // ç‹å† 
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.moveTo(screenX + 20, this.y - 5);
                ctx.lineTo(screenX + 25, this.y - 15);
                ctx.lineTo(screenX + 30, this.y - 8);
                ctx.lineTo(screenX + 35, this.y - 15);
                ctx.lineTo(screenX + 40, this.y - 8);
                ctx.lineTo(screenX + 45, this.y - 15);
                ctx.lineTo(screenX + 50, this.y - 8);
                ctx.lineTo(screenX + 55, this.y - 15);
                ctx.lineTo(screenX + 60, this.y - 5);
                ctx.closePath();
                ctx.fill();

                // ç‹å† ã®å®çŸ³
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(screenX + 25, this.y - 12, 3, 0, Math.PI * 2);
                ctx.arc(screenX + 40, this.y - 12, 3, 0, Math.PI * 2);
                ctx.arc(screenX + 55, this.y - 12, 3, 0, Math.PI * 2);
                ctx.fill();

                // ç›®ï¼ˆå¤§ããå¨åœ§çš„ï¼‰
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(screenX + 25, this.y + 35, 10, 0, Math.PI * 2);
                ctx.arc(screenX + 55, this.y + 35, 10, 0, Math.PI * 2);
                ctx.fill();

                // é»’ç›®ï¼ˆæ€’ã£ãŸè¡¨æƒ…ï¼‰
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(screenX + 26, this.y + 37, 6, 0, Math.PI * 2);
                ctx.arc(screenX + 56, this.y + 37, 6, 0, Math.PI * 2);
                ctx.fill();

                // çœ‰æ¯›ï¼ˆæ€’ã‚Šï¼‰
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(screenX + 15, this.y + 25);
                ctx.lineTo(screenX + 30, this.y + 30);
                ctx.moveTo(screenX + 65, this.y + 25);
                ctx.lineTo(screenX + 50, this.y + 30);
                ctx.stroke();

                // å£ï¼ˆå¤§ããé–‹ã„ãŸï¼‰
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, this.y + 55, 15, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // ç‰™
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(screenX + 30, this.y + 50);
                ctx.lineTo(screenX + 25, this.y + 60);
                ctx.lineTo(screenX + 35, this.y + 55);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(screenX + 50, this.y + 50);
                ctx.lineTo(screenX + 55, this.y + 60);
                ctx.lineTo(screenX + 45, this.y + 55);
                ctx.closePath();
                ctx.fill();

                // è¶³ï¼ˆæ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                ctx.fillStyle = '#654321';
                const footOffset = walkFrame === 0 ? 0 : 5;
                ctx.fillRect(screenX + 20 - footOffset, this.y + 70, 15, 10);
                ctx.fillRect(screenX + 45 + footOffset, this.y + 70, 15, 10);

                // HPãƒãƒ¼
                const barWidth = this.width;
                const barHeight = 8;
                const barX = screenX;
                const barY = this.y - 20;

                // HPãƒãƒ¼èƒŒæ™¯
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // HPï¼ˆç¾åœ¨å€¤ï¼‰
                const hpRatio = this.hp / this.maxHp;
                ctx.fillStyle = hpRatio > 0.5 ? '#2ecc71' : hpRatio > 0.2 ? '#f39c12' : '#e74c3c';
                ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);

                // HPãƒãƒ¼æ 
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);

                // ã€ŒBOSSã€ã®æ–‡å­—
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BOSS', screenX + this.width / 2, barY - 5);
            }

            takeDamage() {
                this.hp--;
                this.hitFlash = 20; // 20ãƒ•ãƒ¬ãƒ¼ãƒ ç‚¹æ»…
                if (this.hp <= 0) {
                    this.isAlive = false;
                }
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }

            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
        }

        // æ•µã‚¯ãƒ©ã‚¹ï¼ˆãƒªã‚¢ãƒ«ç‰ˆï¼‰
        class Enemy {
            constructor(x, y, type) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.velocityX = -1.5; // ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚’é…ã
                this.isAlive = true;
                this.state = 'walking';
                this.shellVelocity = 0;
            }

            update(blocks, pipes, pits) {
                if (!this.isAlive) return;

                if (this.type === 'goomba') {
                    // ç©´ã¨ãƒ‘ã‚¤ãƒ—ã®æ‰‹å‰ã§ãƒã‚§ãƒƒã‚¯ï¼ˆé€²è¡Œæ–¹å‘ï¼‰
                    let shouldTurn = false;

                    // ç©´ãƒã‚§ãƒƒã‚¯
                    if (pits) {
                        pits.forEach(pit => {
                            const checkDistance = 30;
                            if (this.velocityX > 0) {
                                if (this.x + this.width + checkDistance > pit.x &&
                                    this.x < pit.x) {
                                    shouldTurn = true;
                                }
                            } else {
                                if (this.x - checkDistance < pit.x + pit.width &&
                                    this.x > pit.x + pit.width) {
                                    shouldTurn = true;
                                }
                            }
                        });
                    }

                    // ãƒ‘ã‚¤ãƒ—ãƒã‚§ãƒƒã‚¯ï¼ˆæ¥è¿‘å‰ã«æ–¹å‘è»¢æ›ï¼‰
                    if (pipes) {
                        pipes.forEach(pipe => {
                            const pipeRect = pipe.getRect();
                            const checkDistance = 50;
                            if (this.velocityX > 0) {
                                // å³ã«é€²ã‚“ã§ã„ã‚‹å ´åˆã€ãƒ‘ã‚¤ãƒ—ã®å·¦å´ã§ãƒã‚§ãƒƒã‚¯
                                if (this.x + this.width + checkDistance > pipeRect.x &&
                                    this.x < pipeRect.x) {
                                    shouldTurn = true;
                                }
                            } else {
                                // å·¦ã«é€²ã‚“ã§ã„ã‚‹å ´åˆã€ãƒ‘ã‚¤ãƒ—ã®å³å´ã§ãƒã‚§ãƒƒã‚¯
                                if (this.x - checkDistance < pipeRect.x + pipeRect.width &&
                                    this.x > pipeRect.x + pipeRect.width) {
                                    shouldTurn = true;
                                }
                            }
                        });
                    }

                    // æ–¹å‘è»¢æ›
                    if (shouldTurn) {
                        this.velocityX *= -1;
                    }

                    this.x += this.velocityX;

                    let onGround = false;
                    if (this.y + this.height < GROUND_Y) {
                        this.y += GRAVITY;
                    } else {
                        this.y = GROUND_Y - this.height;
                        onGround = true;
                    }

                    blocks.forEach(block => {
                        const blockRect = block.getRect();
                        const enemyRect = this.getRect();
                        if (this.checkCollision(enemyRect, blockRect)) {
                            if (this.y + this.height <= blockRect.y + 10) {
                                this.y = blockRect.y - this.height;
                                onGround = true;
                            } else {
                                this.velocityX *= -1;
                            }
                        }
                    });

                    pipes.forEach(pipe => {
                        const pipeRect = pipe.getRect();
                        const enemyRect = this.getRect();
                        if (this.checkCollision(enemyRect, pipeRect)) {
                            this.velocityX *= -1;
                        }
                    });

                    if (this.x < 0 || this.x > 3000) {
                        this.velocityX *= -1;
                    }
                }

                if (this.type === 'koopa') {
                    if (this.state === 'walking') {
                        // ç©´ã¨ãƒ‘ã‚¤ãƒ—ã®æ‰‹å‰ã§ãƒã‚§ãƒƒã‚¯
                        let shouldTurn = false;

                        // ç©´ãƒã‚§ãƒƒã‚¯
                        if (pits) {
                            pits.forEach(pit => {
                                const checkDistance = 30;
                                if (this.velocityX > 0) {
                                    if (this.x + this.width + checkDistance > pit.x &&
                                        this.x < pit.x) {
                                        shouldTurn = true;
                                    }
                                } else {
                                    if (this.x - checkDistance < pit.x + pit.width &&
                                        this.x > pit.x + pit.width) {
                                        shouldTurn = true;
                                    }
                                }
                            });
                        }

                        // ãƒ‘ã‚¤ãƒ—ãƒã‚§ãƒƒã‚¯
                        if (pipes) {
                            pipes.forEach(pipe => {
                                const pipeRect = pipe.getRect();
                                const checkDistance = 50;
                                if (this.velocityX > 0) {
                                    if (this.x + this.width + checkDistance > pipeRect.x &&
                                        this.x < pipeRect.x) {
                                        shouldTurn = true;
                                    }
                                } else {
                                    if (this.x - checkDistance < pipeRect.x + pipeRect.width &&
                                        this.x > pipeRect.x + pipeRect.width) {
                                        shouldTurn = true;
                                    }
                                }
                            });
                        }

                        // æ–¹å‘è»¢æ›
                        if (shouldTurn) {
                            this.velocityX *= -1;
                        }

                        this.x += this.velocityX;

                        if (this.y + this.height < GROUND_Y) {
                            this.y += GRAVITY;
                        } else {
                            this.y = GROUND_Y - this.height;
                        }

                        blocks.forEach(block => {
                            const blockRect = block.getRect();
                            const enemyRect = this.getRect();
                            if (this.checkCollision(enemyRect, blockRect)) {
                                if (this.y + this.height <= blockRect.y + 10) {
                                    this.y = blockRect.y - this.height;
                                } else {
                                    this.velocityX *= -1;
                                }
                            }
                        });

                        pipes.forEach(pipe => {
                            const pipeRect = pipe.getRect();
                            const enemyRect = this.getRect();
                            if (this.checkCollision(enemyRect, pipeRect)) {
                                this.velocityX *= -1;
                            }
                        });

                        if (this.x < 0 || this.x > 3000) {
                            this.velocityX *= -1;
                        }
                    } else if (this.state === 'shell') {
                        this.height = 30;
                        this.y = GROUND_Y - this.height;
                    } else if (this.state === 'shellMoving') {
                        this.x += this.shellVelocity;
                        this.height = 30;

                        // ç©´ã«è½ã¡ãŸã‹ãƒã‚§ãƒƒã‚¯ï¼ˆç”²ç¾…ã‚’æ¶ˆã™ï¼‰
                        if (pits) {
                            pits.forEach(pit => {
                                if (this.x + this.width / 2 > pit.x &&
                                    this.x + this.width / 2 < pit.x + pit.width &&
                                    this.y + this.height >= GROUND_Y) {
                                    this.isAlive = false; // ç”²ç¾…ã‚’æ¶ˆã™
                                }
                            });
                        }

                        // ãƒ‘ã‚¤ãƒ—ã«å½“ãŸã£ãŸã‚‰è·³ã­è¿”ã‚‹
                        pipes.forEach(pipe => {
                            const pipeRect = pipe.getRect();
                            const enemyRect = this.getRect();
                            if (this.checkCollision(enemyRect, pipeRect)) {
                                // è·³ã­è¿”ã‚‹
                                this.shellVelocity *= -1;
                                // ãƒ‘ã‚¤ãƒ—ã‹ã‚‰é›¢ã™ï¼ˆã‚ã‚Šè¾¼ã¿é˜²æ­¢ï¼‰
                                if (this.shellVelocity > 0) {
                                    this.x = pipeRect.x + pipeRect.width + 2;
                                } else {
                                    this.x = pipeRect.x - this.width - 2;
                                }
                            }
                        });
                    }
                }
            }

            draw() {
                if (!this.isAlive) return;

                const screenX = this.x - cameraX;
                const walkFrame = Math.floor(animationFrame / 10) % 2;

                if (this.type === 'goomba') {
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.ellipse(screenX + this.width / 2, this.y + 20, 18, 16, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#A0522D';
                    ctx.beginPath();
                    ctx.arc(screenX + 10, this.y + 8, 4, 0, Math.PI * 2);
                    ctx.arc(screenX + 30, this.y + 8, 4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(screenX + 12, this.y + 18, 6, 0, Math.PI * 2);
                    ctx.arc(screenX + 28, this.y + 18, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(screenX + 13, this.y + 19, 3, 0, Math.PI * 2);
                    ctx.arc(screenX + 29, this.y + 19, 3, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(screenX + 8, this.y + 14);
                    ctx.lineTo(screenX + 16, this.y + 16);
                    ctx.moveTo(screenX + 32, this.y + 14);
                    ctx.lineTo(screenX + 24, this.y + 16);
                    ctx.stroke();

                    ctx.fillStyle = '#654321';
                    const footOffset = walkFrame === 0 ? 0 : 3;
                    ctx.fillRect(screenX + 10 - footOffset, this.y + 36, 8, 4);
                    ctx.fillRect(screenX + 22 + footOffset, this.y + 36, 8, 4);
                }

                if (this.type === 'koopa') {
                    if (this.state === 'walking') {
                        ctx.fillStyle = '#2ecc71';
                        ctx.beginPath();
                        ctx.ellipse(screenX + 20, this.y + 15, 18, 14, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.strokeStyle = '#27ae60';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(screenX + 20, this.y + 15, 14, 0, Math.PI * 2);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(screenX + 20, this.y + 8);
                        ctx.lineTo(screenX + 20, this.y + 22);
                        ctx.moveTo(screenX + 12, this.y + 15);
                        ctx.lineTo(screenX + 28, this.y + 15);
                        ctx.stroke();

                        ctx.fillStyle = '#f39c12';
                        ctx.beginPath();
                        const headDir = this.velocityX > 0 ? -8 : 8;
                        ctx.arc(screenX + 20 + headDir, this.y + 8, 8, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(screenX + 20 + headDir - 2, this.y + 7, 3, 0, Math.PI * 2);
                        ctx.arc(screenX + 20 + headDir + 2, this.y + 7, 3, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(screenX + 20 + headDir - 2, this.y + 7, 1.5, 0, Math.PI * 2);
                        ctx.arc(screenX + 20 + headDir + 2, this.y + 7, 1.5, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = '#e67e22';
                        const footOffset = walkFrame === 0 ? 0 : 4;
                        ctx.fillRect(screenX + 8 - footOffset, this.y + 28, 10, 12);
                        ctx.fillRect(screenX + 22 + footOffset, this.y + 28, 10, 12);

                        ctx.strokeStyle = '#f39c12';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        const tailDir = this.velocityX > 0 ? 1 : -1;
                        ctx.moveTo(screenX + 20 - tailDir * 18, this.y + 20);
                        ctx.lineTo(screenX + 20 - tailDir * 24, this.y + 18);
                        ctx.stroke();
                    } else {
                        // ç”²ç¾…çŠ¶æ…‹ï¼ˆäº€ã®ç”²ç¾…é¢¨ï¼‰
                        const shellCenterX = screenX + this.width / 2;
                        const shellCenterY = this.y + this.height / 2;
                        const shellRadius = this.width / 2;

                        // ç”²ç¾…ã®å½±
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.beginPath();
                        ctx.ellipse(shellCenterX, shellCenterY + 2, shellRadius, shellRadius * 0.8, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // ç”²ç¾…æœ¬ä½“ï¼ˆæ¥•å††å½¢ï¼‰
                        ctx.fillStyle = '#2ecc71';
                        ctx.beginPath();
                        ctx.ellipse(shellCenterX, shellCenterY, shellRadius, shellRadius * 0.8, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // ç”²ç¾…ã®ç¸å–ã‚Š
                        ctx.strokeStyle = '#27ae60';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.ellipse(shellCenterX, shellCenterY, shellRadius, shellRadius * 0.8, 0, 0, Math.PI * 2);
                        ctx.stroke();

                        // ç”²ç¾…ã®æ¨¡æ§˜ï¼ˆå…­è§’å½¢ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
                        ctx.strokeStyle = '#1e8449';
                        ctx.lineWidth = 2;

                        // ä¸­å¤®ã®å…­è§’å½¢
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            const x = shellCenterX + Math.cos(angle) * 8;
                            const y = shellCenterY + Math.sin(angle) * 6;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.stroke();

                        // ä¸­å¤®ã‹ã‚‰æ”¾å°„çŠ¶ã®ç·š
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            ctx.beginPath();
                            ctx.moveTo(shellCenterX, shellCenterY);
                            ctx.lineTo(
                                shellCenterX + Math.cos(angle) * shellRadius * 0.7,
                                shellCenterY + Math.sin(angle) * shellRadius * 0.7 * 0.8
                            );
                            ctx.stroke();
                        }

                        // ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆç«‹ä½“æ„Ÿï¼‰
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.beginPath();
                        ctx.ellipse(shellCenterX - 5, shellCenterY - 5, 8, 6, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // å‹•ã„ã¦ã„ã‚‹å ´åˆã¯å›è»¢ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                        if (this.state === 'shellMoving') {
                            const spinAngle = (animationFrame * 0.5) % (Math.PI * 2);
                            ctx.save();
                            ctx.translate(shellCenterX, shellCenterY);
                            ctx.rotate(spinAngle);

                            // å›è»¢ç·š
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(-shellRadius * 0.5, 0);
                            ctx.lineTo(shellRadius * 0.5, 0);
                            ctx.stroke();

                            ctx.restore();
                        }
                    }
                }
            }

            stomp() {
                if (this.type === 'goomba') {
                    this.isAlive = false;
                    score += 200;
                    updateScore();
                } else if (this.type === 'koopa') {
                    if (this.state === 'walking') {
                        this.state = 'shell';
                        this.velocityX = 0;
                        this.y = GROUND_Y - 30;
                        score += 300;
                        updateScore();
                    }
                }
            }

            kickShell(direction) {
                if (this.type === 'koopa' && this.state === 'shell') {
                    this.state = 'shellMoving';
                    this.shellVelocity = direction > 0 ? 12 : -12;
                }
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }

            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
        }

        // ã‚´ãƒ¼ãƒ«ï¼ˆæ——ï¼‰ã‚¯ãƒ©ã‚¹
        class Goal {
            constructor(x) {
                this.x = x;
                this.y = GROUND_Y - 180;
                this.width = 20;
                this.height = 180;
                this.flagWidth = 60;
                this.flagHeight = 50;
            }

            draw() {
                const screenX = this.x - cameraX;

                ctx.fillStyle = '#666';
                ctx.fillRect(screenX, this.y, this.width, this.height);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(screenX + this.width / 2, this.y, this.width / 2, this.height);

                const flagY = this.y + Math.sin(animationFrame * 0.1) * 5;
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(screenX + this.width, flagY);
                ctx.lineTo(screenX + this.width + this.flagWidth, flagY + this.flagHeight / 2);
                ctx.lineTo(screenX + this.width, flagY + this.flagHeight);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = '#c0392b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenX + this.width, flagY);
                ctx.lineTo(screenX + this.width + this.flagWidth, flagY + this.flagHeight / 2);
                ctx.lineTo(screenX + this.width, flagY + this.flagHeight);
                ctx.closePath();
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('â˜…', screenX + this.width + this.flagWidth / 2, flagY + this.flagHeight / 2 + 8);
            }

            checkCollision(player) {
                return player.x + player.width >= this.x &&
                       player.x <= this.x + this.width + this.flagWidth;
            }
        }

        // å½“ãŸã‚Šåˆ¤å®šé–¢æ•°
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // ã‚¹ã‚³ã‚¢æ›´æ–°
        function updateScore() {
            document.getElementById('scoreValue').textContent = score;
        }

        // ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        let player;
        let enemies;
        let blocks;
        let pipes;
        let pits;
        let goal;
        let items;
        let boss;

        function initGame() {
            player = new Player();
            score = 0;
            updateScore();

            // ãƒ–ãƒ­ãƒƒã‚¯ã®é…ç½®ï¼ˆå¿…è¦æœ€å°é™ã«èª¿æ•´ï¼‰
            blocks = [
                new Block(300, GROUND_Y - 120, 'question', 'coin'),
                new Block(380, GROUND_Y - 120, 'question', 'mushroom'),

                new Block(1050, GROUND_Y - 120, 'question', 'coin'),

                new Block(1380, GROUND_Y - 120, 'question', 'star'),

                new Block(2400, GROUND_Y - 120, 'question', 'mushroom'),

                new Block(2950, GROUND_Y - 200, 'question', 'star'),

                new Block(3640, GROUND_Y - 120, 'question', 'coin'),

                new Block(4180, GROUND_Y - 150, 'question', 'mushroom')
            ];

            pipes = [
                new Pipe(620, 60),
                new Pipe(970, 80),
                new Pipe(1580, 100),
                new Pipe(1900, 80),
                // è¿½åŠ ãƒ‘ã‚¤ãƒ—
                new Pipe(2600, 70),
                new Pipe(3100, 90),
                new Pipe(3650, 80), // 3500â†’3650 (ç©´3450-3570ã‚’é¿ã‘ã‚‹)
                new Pipe(4150, 100) // 3900â†’4150 (ç©´4000-4100ã‚’é¿ã‘ã‚‹)
            ];

            pits = [
                new Pit(1200, 120),
                new Pit(1800, 80),
                new Pit(2300, 100),
                // è¿½åŠ ç©´
                new Pit(2850, 100),
                new Pit(3450, 120),
                new Pit(4000, 100)
            ];

            enemies = [
                new Enemy(450, GROUND_Y - 40, 'goomba'),
                new Enemy(750, GROUND_Y - 40, 'koopa'),  // ãƒ‘ã‚¤ãƒ—620ã‹ã‚‰é›¢ã™
                new Enemy(1100, GROUND_Y - 40, 'goomba'), // ãƒ‘ã‚¤ãƒ—970ã‹ã‚‰é›¢ã™
                new Enemy(1350, GROUND_Y - 40, 'goomba'),
                new Enemy(1750, GROUND_Y - 40, 'koopa'),  // ãƒ‘ã‚¤ãƒ—1580ã¨1900ã®é–“
                new Enemy(2050, GROUND_Y - 40, 'goomba'), // ãƒ‘ã‚¤ãƒ—1900ã®å¾Œ
                new Enemy(2400, GROUND_Y - 40, 'koopa'),  // ãƒ‘ã‚¤ãƒ—2600ã®æ‰‹å‰
                new Enemy(2750, GROUND_Y - 40, 'goomba'), // ãƒ‘ã‚¤ãƒ—2600ã®å¾Œã€ç©´2850ã®æ‰‹å‰
                new Enemy(2950, GROUND_Y - 40, 'koopa'),  // ç©´2850ã®å¾Œã€ãƒ‘ã‚¤ãƒ—3100ã®æ‰‹å‰
                new Enemy(3250, GROUND_Y - 40, 'goomba'), // ãƒ‘ã‚¤ãƒ—3100ã®å¾Œã€ç©´3450ã®æ‰‹å‰
                new Enemy(3800, GROUND_Y - 40, 'koopa'),  // ç©´3450ã®å¾Œã€ãƒ‘ã‚¤ãƒ—3650ã®å¾Œ
                new Enemy(4300, GROUND_Y - 40, 'goomba')  // ãƒ‘ã‚¤ãƒ—4150ã®å¾Œ
            ];

            items = [];

            // ãƒœã‚¹ï¼ˆã‚´ãƒ¼ãƒ«æ‰‹å‰ï¼‰
            boss = new Boss(4200, GROUND_Y - 80);

            goal = new Goal(4500);

            gameState = 'playing';
            cameraX = 0;
            animationFrame = 0;

            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('gameClear').style.display = 'none';
        }

        // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
        function gameLoop() {
            animationFrame++;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã§ãªã„å ´åˆã®ã¿ã‚²ãƒ¼ãƒ ç”»é¢ã‚’æç”»
            if (gameState !== 'title') {
                // èƒŒæ™¯è£…é£¾ï¼ˆé›²ï¼‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                drawCloud(200 - (cameraX * 0.2) % 400, 80);
                drawCloud(500 - (cameraX * 0.2) % 400, 120);
                drawCloud(800 - (cameraX * 0.2) % 400, 60);

                // åœ°é¢æç”»
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(0, GROUND_Y, canvas.width, GROUND_HEIGHT);

                ctx.fillStyle = '#27ae60';
                ctx.fillRect(0, GROUND_Y, canvas.width, 8);

                ctx.fillStyle = '#654321';
                for (let i = 0; i < canvas.width; i += 40) {
                    ctx.fillRect(i, GROUND_Y + 20, 20, 20);
                }

                pits.forEach(pit => pit.draw());
                pipes.forEach(pipe => pipe.draw());
                blocks.forEach(block => block.draw());

                // ã‚¢ã‚¤ãƒ†ãƒ ã®æ›´æ–°ã¨æç”»
                items.forEach(item => {
                    item.update();
                    item.draw();
                });
            }

            if (gameState === 'playing' || gameState === 'falling' || gameState === 'hit') {
                player.update(blocks, pipes);

                // ãƒ’ãƒƒãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã«ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
                if (gameState === 'hit' && player.y > canvas.height + 100) {
                    gameState = 'gameOver';
                    document.getElementById('gameOverReason').textContent = gameOverReason;
                    document.getElementById('gameOver').style.display = 'block';
                }

                // ãƒ’ãƒƒãƒˆçŠ¶æ…‹ã§ãªã„å ´åˆã®ã¿è¡çªåˆ¤å®šã‚’è¡Œã†
                if (gameState !== 'hit') {
                    // ã‚¢ã‚¤ãƒ†ãƒ ã¨ã®è¡çªåˆ¤å®š
                    items.forEach(item => {
                        if (!item.isCollected) {
                            const playerRect = player.getRect();
                            const itemRect = item.getRect();
                            if (checkCollision(playerRect, itemRect)) {
                                item.collect(player);
                            }
                        }
                    });

                    // ç©´ã«è½ã¡ãŸã‹ãƒã‚§ãƒƒã‚¯
                    if (!player.isFalling) {
                        pits.forEach(pit => {
                            if (pit.checkFall(player)) {
                                gameState = 'falling';
                                player.startFalling();
                            }
                        });
                    }
                }

                // ãƒœã‚¹æ›´æ–°
                if (boss) {
                    boss.update(blocks, pipes, pits);

                    if (gameState !== 'hit' && boss.isAlive) {
                        const playerRect = player.getRect();
                        const bossRect = boss.getRect();

                        // ãƒœã‚¹ã®å½“ãŸã‚Šåˆ¤å®šã‚‚å°‘ã—å°ã•ãã™ã‚‹
                        const bossHitbox = {
                            x: bossRect.x + 8,
                            y: bossRect.y + 8,
                            width: bossRect.width - 16,
                            height: bossRect.height - 16
                        };

                        if (checkCollision(playerRect, bossHitbox)) {
                            // ãƒœã‚¹ã®è¸ã¿ã¤ã‘åˆ¤å®šã‚’å„ªã—ãï¼ˆä¸Šéƒ¨50%ã¾ã§ï¼‰
                            const isStompingFromAbove =
                                player.velocityY > 0 &&
                                playerRect.y + playerRect.height < bossRect.y + bossRect.height * 0.5;

                            if (isStompingFromAbove) {
                                // ãƒœã‚¹ã«ãƒ€ãƒ¡ãƒ¼ã‚¸
                                boss.takeDamage();
                                player.velocityY = JUMP_POWER / 2;
                                score += 500;
                                updateScore();
                            } else {
                                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹ï¼ˆç„¡æ•µä¸­ã§ãªã„å ´åˆã®ã¿ï¼‰
                                if (!player.invincible) {
                                    if (player.isPoweredUp) {
                                        player.powerDown();
                                    } else {
                                        gameState = 'hit';
                                        gameOverReason = 'ãƒœã‚¹ã«ã‚„ã‚‰ã‚Œã¾ã—ãŸ';
                                        player.startHitAnimation(boss.x + boss.width / 2);
                                    }
                                }
                            }
                        }
                    }
                }

                // æ•µæ›´æ–°
                enemies.forEach(enemy => {
                    enemy.update(blocks, pipes, pits);
                });

                // å‹•ã„ã¦ã„ã‚‹ç”²ç¾…ã¨ä»–ã®æ•µã®è¡çªåˆ¤å®š
                enemies.forEach((shell, shellIndex) => {
                    if (!shell.isAlive || shell.type !== 'koopa' || shell.state !== 'shellMoving') return;

                    const shellRect = shell.getRect();

                    enemies.forEach((enemy, enemyIndex) => {
                        if (shellIndex === enemyIndex || !enemy.isAlive) return;

                        const enemyRect = enemy.getRect();
                        if (checkCollision(shellRect, enemyRect)) {
                            // ç”²ç¾…ãŒä»–ã®æ•µã‚’å€’ã™
                            enemy.isAlive = false;
                            score += 200;
                            updateScore();
                        }
                    });
                });

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨æ•µã®è¡çªåˆ¤å®š
                enemies.forEach(enemy => {
                    if (!enemy.isAlive || gameState === 'hit') return;

                    const playerRect = player.getRect();
                    const enemyRect = enemy.getRect();

                    // å½“ãŸã‚Šåˆ¤å®šã‚’å°‘ã—å°ã•ãã—ã¦ä½™è£•ã‚’æŒãŸã›ã‚‹
                    const enemyHitbox = {
                        x: enemyRect.x + 5,
                        y: enemyRect.y + 5,
                        width: enemyRect.width - 10,
                        height: enemyRect.height - 10
                    };

                    if (checkCollision(playerRect, enemyHitbox)) {
                        // è¸ã¿ã¤ã‘åˆ¤å®šã‚’å„ªã—ãï¼ˆæ•µã®ä¸Šéƒ¨60%ã¾ã§ï¼‰
                        const isStompingFromAbove =
                            player.velocityY > 0 &&
                            playerRect.y + playerRect.height - 15 < enemyRect.y + enemyRect.height * 0.6;

                        if (isStompingFromAbove) {
                            enemy.stomp();
                            player.velocityY = JUMP_POWER / 2;
                        } else {
                            if (enemy.type === 'koopa' && enemy.state === 'shell') {
                                const direction = player.x < enemy.x ? 1 : -1;
                                enemy.kickShell(direction);
                            } else if (enemy.type === 'koopa' && enemy.state === 'shellMoving') {
                                // å‹•ã„ã¦ã„ã‚‹ç”²ç¾…ã«å½“ãŸã£ãŸå ´åˆï¼ˆç„¡æ•µä¸­ã§ãªã„å ´åˆã®ã¿ï¼‰
                                if (!player.invincible) {
                                    if (player.isPoweredUp) {
                                        player.powerDown(); // ãƒ‘ãƒ¯ãƒ¼ãƒ€ã‚¦ãƒ³
                                    } else {
                                        gameState = 'hit';
                                        gameOverReason = 'ç”²ç¾…ã«å½“ãŸã‚Šã¾ã—ãŸ';
                                        player.startHitAnimation(enemy.x + enemy.width / 2);
                                    }
                                }
                            } else if (enemy.state === 'walking' || enemy.type === 'goomba') {
                                // é€šå¸¸ã®æ•µã«æ¨ªã‹ã‚‰å½“ãŸã£ãŸå ´åˆï¼ˆç„¡æ•µä¸­ã§ãªã„å ´åˆã®ã¿ï¼‰
                                if (!player.invincible) {
                                    if (player.isPoweredUp) {
                                        player.powerDown(); // ãƒ‘ãƒ¯ãƒ¼ãƒ€ã‚¦ãƒ³
                                    } else {
                                        gameState = 'hit';
                                        gameOverReason = 'æ•µã«å½“ãŸã‚Šã¾ã—ãŸ';
                                        player.startHitAnimation(enemy.x + enemy.width / 2);
                                    }
                                }
                            }
                        }
                    }
                });

                // ã‚´ãƒ¼ãƒ«åˆ¤å®š
                if (goal.checkCollision(player)) {
                    gameState = 'clear';
                    document.getElementById('finalScore').textContent = score;
                    document.getElementById('gameClear').style.display = 'block';
                }
            }

            // æç”»ï¼ˆã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ï¼‰
            if (gameState !== 'title') {
                player.draw();
                enemies.forEach(enemy => enemy.draw());
                if (boss) boss.draw();
                goal.draw();
            }

            requestAnimationFrame(gameLoop);
        }

        // é›²ã‚’æç”»
        function drawCloud(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.arc(x + 25, y, 25, 0, Math.PI * 2);
            ctx.arc(x + 50, y, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆ
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                keys.left = true;
            }
            if (e.key === 'ArrowRight') {
                keys.right = true;
            }
            if (e.key === ' ' || e.key === 'Spacebar') {
                keys.space = true;
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') {
                keys.left = false;
            }
            if (e.key === 'ArrowRight') {
                keys.right = false;
            }
            if (e.key === ' ' || e.key === 'Spacebar') {
                keys.space = false;
            }
        });

        // ã‚¹ã‚¿ãƒ¼ãƒˆé–¢æ•°
        function startGame() {
            document.getElementById('titleScreen').classList.add('hidden');
            initGame();

            // åˆå›èµ·å‹•æ™‚ã«ãƒ¢ãƒã‚¤ãƒ«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«åˆæœŸåŒ–
            if (!isTouchDevice) {
                initMobileControls();
            }
        }

        // ãƒªã‚¹ã‚¿ãƒ¼ãƒˆé–¢æ•°
        function restartGame() {
            document.getElementById('titleScreen').classList.remove('hidden');
            gameState = 'title';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('gameClear').style.display = 'none';
        }

        // ç”»é¢ãƒªã‚µã‚¤ã‚ºã¨ã‚ªãƒªã‚¨ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å¤‰æ›´ã«å¯¾å¿œ
        window.addEventListener('resize', () => {
            if (isTouchDevice) {
                updateCanvasScale();
            }
        });

        window.addEventListener('orientationchange', () => {
            if (isTouchDevice) {
                setTimeout(() => {
                    updateCanvasScale();
                }, 100);
            }
        });

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã®åˆæœŸåŒ–
        window.addEventListener('load', () => {
            initMobileControls();
        });

        // ã‚²ãƒ¼ãƒ é–‹å§‹
        gameLoop();
    </script>
</body>
</html>