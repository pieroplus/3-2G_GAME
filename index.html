<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3-2G „Éñ„É©„Ç∂„Éº„Ç∫</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            font-family: 'Arial', sans-serif;
        }

        #gameContainer {
            position: relative;
        }

        canvas {
            border: 3px solid #333;
            display: block;
            background: linear-gradient(to bottom, #5c9fd8 0%, #8fc9f5 100%);
        }

        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #titleScreen.hidden {
            display: none;
        }

        .title-logo {
            font-size: 72px;
            font-weight: bold;
            color: #fff;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            animation: titleBounce 2s ease-in-out infinite;
        }

        @keyframes titleBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .title-subtitle {
            font-size: 24px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 50px;
        }

        .start-btn {
            padding: 20px 60px;
            font-size: 28px;
            background: linear-gradient(to bottom, #4CAF50 0%, #45a049 100%);
            color: white;
            border: 4px solid #fff;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            font-weight: bold;
        }

        .start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
        }

        .start-btn:active {
            transform: scale(0.95);
        }

        .title-character {
            font-size: 48px;
            margin-top: 30px;
            animation: characterWalk 1s steps(2) infinite;
        }

        @keyframes characterWalk {
            0%, 100% { content: 'üö∂'; }
            50% { content: 'üö∂‚Äç‚ôÇÔ∏è'; }
        }

        #gameOver, #gameClear {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px 60px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 4px solid #fff;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        #gameOver h1 {
            font-size: 48px;
            color: #ff4444;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #gameClear h1 {
            font-size: 48px;
            color: #44ff44;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .restart-btn {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .restart-btn:hover {
            background-color: #45a049;
        }

        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 250px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        #instructions h3 {
            margin-bottom: 10px;
            color: #333;
        }

        #instructions p {
            margin: 5px 0;
            color: #555;
        }

        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #ffd700;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="600"></canvas>

        <!-- „Çø„Ç§„Éà„É´ÁîªÈù¢ -->
        <div id="titleScreen">
            <div class="title-logo">3-2G „Éñ„É©„Ç∂„Éº„Ç∫</div>
            <div class="title-subtitle">ÔΩû ÂÜíÈô∫„ÅÆÂßã„Åæ„Çä ÔΩû</div>
            <button class="start-btn" onclick="startGame()">„Çπ„Çø„Éº„Éà</button>
            <div class="title-character">üë§</div>
        </div>

        <div id="instructions">
            <h3>Êìç‰ΩúÊñπÊ≥ï</h3>
            <p>‚Üê ‚Üí : ÁßªÂãï</p>
            <p>„Çπ„Éö„Éº„Çπ : „Ç∏„É£„É≥„Éó</p>
            <p>„ÉªÊïµ„Çí‰∏ä„Åã„ÇâË∏è„Çì„ÅßÂÄí„Åù„ÅÜÔºÅ</p>
            <p>„Éª?„Éñ„É≠„ÉÉ„ÇØ„Åã„Çâ„Ç¢„Ç§„ÉÜ„É†GET</p>
            <p>„ÉªÁ©¥„Å´ËêΩ„Å°„Å™„ÅÑ„Çà„ÅÜ„Å´Ê≥®ÊÑèÔºÅ</p>
            <p>„Éª<strong>„Éú„Çπ„Å´ÊåëÊà¶</strong>„Åó„Å¶Êóó„Å´Âà∞ÈÅîÔºÅ</p>
        </div>

        <div id="score">
            „Çπ„Ç≥„Ç¢: <span id="scoreValue">0</span>
        </div>

        <div id="gameOver">
            <h1>GAME OVER</h1>
            <p id="gameOverReason">„ÇÑ„Çâ„Çå„Åæ„Åó„Åü</p>
            <button class="restart-btn" onclick="restartGame()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§</button>
        </div>

        <div id="gameClear">
            <h1>CLEAR!</h1>
            <p>„Çπ„ÉÜ„Éº„Ç∏„ÇØ„É™„Ç¢„Åä„ÇÅ„Åß„Å®„ÅÜÔºÅ</p>
            <p>„Çπ„Ç≥„Ç¢: <span id="finalScore">0</span></p>
            <button class="restart-btn" onclick="restartGame()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§</button>
        </div>
    </div>

    <script>
        // CanvasË®≠ÂÆö
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // „Ç≤„Éº„É†ÂÆöÊï∞
        const GRAVITY = 0.6;
        const JUMP_POWER = -14;
        const MOVE_SPEED = 5;
        const GROUND_Y = canvas.height - 80;
        const GROUND_HEIGHT = 80;

        // „Ç≤„Éº„É†Áä∂ÊÖã
        let gameState = 'title'; // 'title', 'playing', 'falling', 'hit', 'gameOver', 'clear'
        let gameOverReason = ''; // „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„ÅÆÁêÜÁî±„Çí‰øùÂ≠ò
        let cameraX = 0; // „Ç´„É°„É©„ÅÆXÂ∫ßÊ®ôÔºà„Çπ„ÇØ„É≠„Éº„É´Áî®Ôºâ
        let animationFrame = 0; // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®„Éï„É¨„Éº„É†„Ç´„Ç¶„É≥„Çø„Éº
        let score = 0; // „Çπ„Ç≥„Ç¢

        // „Ç≠„ÉºÂÖ•ÂäõÁÆ°ÁêÜ
        const keys = {
            left: false,
            right: false,
            space: false
        };

        // „Ç¢„Ç§„ÉÜ„É†„ÇØ„É©„Çπ
        class Item {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'coin', 'mushroom', 'star'
                this.width = 30;
                this.height = 30;
                this.velocityY = -8; // Âá∫ÁèæÊôÇ„ÅÆ‰∏äÊòá
                this.velocityX = 0;
                this.isCollected = false;
                this.isEmerging = true; // Âá∫Áèæ‰∏≠„Éï„É©„Ç∞
                this.emergeStartY = y;
            }

            update() {
                if (this.isCollected) return;

                if (this.isEmerging) {
                    // „Éñ„É≠„ÉÉ„ÇØ„Åã„ÇâÂá∫Áèæ‰∏≠
                    this.y += this.velocityY;
                    if (this.y <= this.emergeStartY - 40) {
                        this.isEmerging = false;
                        this.velocityY = 0;
                        if (this.type === 'mushroom') {
                            this.velocityX = 2; // „Ç≠„Éé„Ç≥„ÅØÊ®™„Å´Âãï„Åè
                        }
                    }
                } else {
                    if (this.type === 'coin') {
                        // „Ç≥„Ç§„É≥„ÅØÊµÆÈÅä
                        this.y += Math.sin(animationFrame * 0.1) * 0.5;
                    } else if (this.type === 'mushroom') {
                        // „Ç≠„Éé„Ç≥„ÅØÊ®™ÁßªÂãïÔºãÈáçÂäõ
                        this.x += this.velocityX;
                        this.velocityY += GRAVITY;
                        this.y += this.velocityY;

                        // Âú∞Èù¢„Å®„ÅÆË°ùÁ™Å
                        if (this.y + this.height >= GROUND_Y) {
                            this.y = GROUND_Y - this.height;
                            this.velocityY = 0;
                        }

                        // Â£Å„ÅßÂèçËª¢
                        if (this.x < 0 || this.x > 3000) {
                            this.velocityX *= -1;
                        }
                    } else if (this.type === 'star') {
                        // „Çπ„Çø„Éº„ÅØË∑≥„Å≠„Çã
                        this.x += this.velocityX;
                        this.velocityY += GRAVITY;
                        this.y += this.velocityY;

                        if (this.y + this.height >= GROUND_Y) {
                            this.y = GROUND_Y - this.height;
                            this.velocityY = -10;
                        }
                    }
                }
            }

            draw() {
                if (this.isCollected) return;

                const screenX = this.x - cameraX;

                if (this.type === 'coin') {
                    // „Ç≥„Ç§„É≥ÔºàÈáëËâ≤Ôºâ
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, this.y + this.height / 2, 12, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#ff8c00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, this.y + this.height / 2, 12, 0, Math.PI * 2);
                    ctx.stroke();

                    // Ëºù„Åç
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2 - 4, this.y + this.height / 2 - 4, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'mushroom') {
                    // „Ç≠„Éé„Ç≥ÔºàËµ§„Å®ÁôΩÔºâ
                    // ÂÇò
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, this.y + 12, 14, Math.PI, 0, false);
                    ctx.fill();

                    // ÁôΩ„ÅÑÊñëÁÇπ
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2 - 6, this.y + 8, 4, 0, Math.PI * 2);
                    ctx.arc(screenX + this.width / 2 + 6, this.y + 8, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // ÊüÑ
                    ctx.fillStyle = '#ecf0f1';
                    ctx.fillRect(screenX + this.width / 2 - 6, this.y + 12, 12, 16);

                    // ÁõÆ
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2 - 4, this.y + 18, 2, 0, Math.PI * 2);
                    ctx.arc(screenX + this.width / 2 + 4, this.y + 18, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'star') {
                    // „Çπ„Çø„ÉºÔºàËôπËâ≤Ôºâ
                    const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
                    const colorIndex = Math.floor(animationFrame / 5) % colors.length;
                    ctx.fillStyle = colors[colorIndex];

                    // ÊòüÂΩ¢
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                        const x = screenX + this.width / 2 + Math.cos(angle) * 14;
                        const y = this.y + this.height / 2 + Math.sin(angle) * 14;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }

            collect(player) {
                this.isCollected = true;
                if (this.type === 'coin') {
                    score += 100;
                } else if (this.type === 'mushroom') {
                    score += 500;
                    player.powerUp(); // „Éó„É¨„Ç§„É§„Éº„Çí„Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó
                } else if (this.type === 'star') {
                    score += 1000;
                    // ÁÑ°ÊïµÁä∂ÊÖã„Å™„Å©
                }
                updateScore();
            }
        }

        // „Éñ„É≠„ÉÉ„ÇØ„ÇØ„É©„Çπ
        class Block {
            constructor(x, y, type = 'brick', itemType = null) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.type = type; // 'brick', 'question', 'stone'
                this.isHit = false; // „Éè„ÉÜ„Éä„Éñ„É≠„ÉÉ„ÇØ„ÅåÂè©„Åã„Çå„Åü„Åã
                this.itemType = itemType; // 'coin', 'mushroom', 'star', null
                this.bounceOffset = 0; // Âè©„Åã„Çå„ÅüÊôÇ„ÅÆ„Éê„Ç¶„É≥„Éâ
            }

            draw() {
                const screenX = this.x - cameraX;
                const drawY = this.y + this.bounceOffset;

                if (this.type === 'brick') {
                    // „É¨„É≥„Ç¨„Éñ„É≠„ÉÉ„ÇØ
                    ctx.fillStyle = '#c95a27';
                    ctx.fillRect(screenX, drawY, this.width, this.height);

                    // „É¨„É≥„Ç¨Ê®°Êßò
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, drawY, this.width, this.height);
                    ctx.beginPath();
                    ctx.moveTo(screenX + this.width / 2, drawY);
                    ctx.lineTo(screenX + this.width / 2, drawY + this.height);
                    ctx.stroke();
                } else if (this.type === 'question') {
                    // „Éè„ÉÜ„Éä„Éñ„É≠„ÉÉ„ÇØ
                    if (this.isHit) {
                        ctx.fillStyle = '#8B7355';
                    } else {
                        // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂäπÊûú
                        const brightness = 180 + Math.sin(animationFrame * 0.1) * 20;
                        ctx.fillStyle = `rgb(${brightness}, ${brightness - 20}, 96)`;
                    }
                    ctx.fillRect(screenX, drawY, this.width, this.height);

                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, drawY, this.width, this.height);

                    if (!this.isHit) {
                        // Ôºü„Éû„Éº„ÇØÔºà„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ôºâ
                        const offsetY = Math.sin(animationFrame * 0.1) * 2;
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 28px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('?', screenX + this.width / 2, drawY + this.height / 2 + offsetY);
                    }
                } else if (this.type === 'stone') {
                    // Áü≥„Éñ„É≠„ÉÉ„ÇØ
                    ctx.fillStyle = '#888';
                    ctx.fillRect(screenX, drawY, this.width, this.height);

                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, drawY, this.width, this.height);
                }

                // „Éê„Ç¶„É≥„Éâ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Êõ¥Êñ∞
                if (this.bounceOffset < 0) {
                    this.bounceOffset += 2;
                    if (this.bounceOffset > 0) this.bounceOffset = 0;
                }
            }

            hit() {
                if (this.type === 'question' && !this.isHit) {
                    this.isHit = true;
                    this.bounceOffset = -10; // „Éê„Ç¶„É≥„ÉâÂäπÊûú

                    // „Ç¢„Ç§„ÉÜ„É†„ÇíÁîüÊàê
                    if (this.itemType) {
                        const item = new Item(this.x + 5, this.y, this.itemType);
                        items.push(item);
                    }
                }
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
        }

        // „Éë„Ç§„ÉóÔºà„Éâ„Ç´„É≥Ôºâ„ÇØ„É©„Çπ
        class Pipe {
            constructor(x, height = 80) {
                this.x = x;
                this.height = height;
                this.width = 60;
                this.y = GROUND_Y - this.height;
            }

            draw() {
                const screenX = this.x - cameraX;

                // „Éë„Ç§„ÉóÊú¨‰ΩìÔºàÁ∑ëÔºâ
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(screenX, this.y, this.width, this.height);

                // „Éë„Ç§„Éó„ÅÆÁ∏ÅÂèñ„Çä
                ctx.strokeStyle = '#27ae60';
                ctx.lineWidth = 3;
                ctx.strokeRect(screenX, this.y, this.width, this.height);

                // „Éë„Ç§„Éó„ÅÆÂè£
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(screenX - 5, this.y - 10, this.width + 10, 15);
                ctx.strokeStyle = '#1e8449';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX - 5, this.y - 10, this.width + 10, 15);

                // ÂΩ±ÔºàÁ´ã‰ΩìÊÑüÔºâ
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(screenX + this.width / 2, this.y, this.width / 2, this.height);

                // ÂÜÖÂÅ¥„ÅÆÂΩ±
                ctx.fillStyle = '#000';
                ctx.fillRect(screenX + 10, this.y - 8, this.width - 20, 10);
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
        }

        // Á©¥„ÇØ„É©„Çπ
        class Pit {
            constructor(x, width) {
                this.x = x;
                this.width = width;
                this.y = GROUND_Y;
            }

            draw() {
                const screenX = this.x - cameraX;

                // Á©¥ÔºàÈªíÔºâ
                ctx.fillStyle = '#000';
                ctx.fillRect(screenX, this.y, this.width, GROUND_HEIGHT);
            }

            checkFall(player) {
                // „Éó„É¨„Ç§„É§„Éº„ÅÆ70%‰ª•‰∏ä„ÅåÁ©¥„ÅÆ‰∏ä„Å´„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„ÅøËêΩ‰∏ã
                const playerLeft = player.x + player.width * 0.15;
                const playerRight = player.x + player.width * 0.85;
                return playerLeft > this.x &&
                       playerRight < this.x + this.width &&
                       player.y + player.height >= GROUND_Y;
            }
        }

        // „Éó„É¨„Ç§„É§„Éº„ÇØ„É©„ÇπÔºà3-2GÊñáÂ≠ó„Ç≠„É£„É©Ôºâ
        class Player {
            constructor() {
                this.normalWidth = 50;
                this.normalHeight = 40;
                this.powerWidth = 100;
                this.powerHeight = 80;

                this.width = this.normalWidth;
                this.height = this.normalHeight;
                this.x = 100;
                this.y = GROUND_Y - this.height;
                this.velocityX = 0;
                this.velocityY = 0;
                this.isJumping = false;
                this.isOnGround = false;
                this.direction = 1; // 1: Âè≥Âêë„Åç, -1: Â∑¶Âêë„Åç
                this.isFalling = false; // Á©¥„Å´ËêΩ„Å°„Å¶„ÅÑ„Çã„Åã
                this.fallRotation = 0; // ËêΩ‰∏ãÊôÇ„ÅÆÂõûËª¢
                this.isPoweredUp = false; // „Éë„ÉØ„Éº„Ç¢„ÉÉ„ÉóÁä∂ÊÖã
                this.powerUpAnimation = 0; // „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®
                this.isHit = false; // Êïµ„Å´ÂΩì„Åü„Å£„ÅüÁä∂ÊÖã
                this.hitKnockbackX = 0; // „Éé„ÉÉ„ÇØ„Éê„ÉÉ„ÇØÊñπÂêë
                this.invincible = false; // ÁÑ°ÊïµÁä∂ÊÖã
                this.invincibleTimer = 0; // ÁÑ°ÊïµÊôÇÈñì„Ç´„Ç¶„É≥„Çø„Éº
            }

            update(blocks, pipes) {
                // ÁÑ°ÊïµÊôÇÈñì„ÅÆÊõ¥Êñ∞
                if (this.invincibleTimer > 0) {
                    this.invincibleTimer--;
                    if (this.invincibleTimer === 0) {
                        this.invincible = false;
                    }
                }

                // „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                if (this.powerUpAnimation > 0) {
                    this.powerUpAnimation--;
                    // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥‰∏≠„ÅØ„Çµ„Ç§„Ç∫„ÅåÂ§âÂåñ
                    const progress = (30 - this.powerUpAnimation) / 30;
                    if (this.isPoweredUp) {
                        this.width = this.normalWidth + (this.powerWidth - this.normalWidth) * progress;
                        this.height = this.normalHeight + (this.powerHeight - this.normalHeight) * progress;
                    } else {
                        this.width = this.powerWidth - (this.powerWidth - this.normalWidth) * progress;
                        this.height = this.powerHeight - (this.powerHeight - this.normalHeight) * progress;
                    }
                    this.y = GROUND_Y - this.height;
                }

                if (this.isFalling) {
                    // Á©¥„Å´ËêΩ‰∏ã‰∏≠ÔºàÂõûËª¢„Å™„Åó„ÄÅ„Åù„ÅÆ„Åæ„ÅæËêΩ„Å°„ÇãÔºâ
                    this.velocityY += GRAVITY * 1.5;
                    this.y += this.velocityY;

                    // ÁîªÈù¢Â§ñ„Å´Âá∫„Åü„Çâ„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº
                    if (this.y > canvas.height + 100) {
                        gameState = 'gameOver';
                        document.getElementById('gameOverReason').textContent = 'Á©¥„Å´ËêΩ„Å°„Åæ„Åó„Åü';
                        document.getElementById('gameOver').style.display = 'block';
                    }
                    return;
                }

                if (this.isHit) {
                    // Êïµ„Å´ÂΩì„Åü„Å£„ÅüÊôÇ„ÅÆ„Éé„ÉÉ„ÇØ„Éê„ÉÉ„ÇØ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                    this.x += this.hitKnockbackX;
                    this.velocityY += GRAVITY * 1.5;
                    this.y += this.velocityY;
                    this.fallRotation += 0.15;
                    return;
                }

                // Â∑¶Âè≥ÁßªÂãï
                if (keys.left) {
                    this.velocityX = -MOVE_SPEED;
                    this.direction = -1;
                } else if (keys.right) {
                    this.velocityX = MOVE_SPEED;
                    this.direction = 1;
                } else {
                    this.velocityX = 0;
                }

                // „Ç∏„É£„É≥„Éó
                if (keys.space && this.isOnGround && !this.isJumping) {
                    this.velocityY = JUMP_POWER;
                    this.isJumping = true;
                    this.isOnGround = false;
                }

                // „Çπ„Éö„Éº„Çπ„Ç≠„Éº„ÅåÈõ¢„Åï„Çå„Åü„Çâ„Ç∏„É£„É≥„Éó„Éï„É©„Ç∞„Çí„É™„Çª„ÉÉ„Éà
                if (!keys.space) {
                    this.isJumping = false;
                }

                // ÈáçÂäõÈÅ©Áî®
                this.velocityY += GRAVITY;

                // ‰ΩçÁΩÆÊõ¥Êñ∞ÔºàXËª∏Ôºâ
                this.x += this.velocityX;

                // „Éë„Ç§„Éó„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆöÔºàÊ®™Ôºâ
                pipes.forEach(pipe => {
                    const pipeRect = pipe.getRect();
                    const playerRect = this.getRect();

                    if (this.checkCollision(playerRect, pipeRect)) {
                        if (this.velocityX > 0) {
                            this.x = pipeRect.x - this.width;
                        } else if (this.velocityX < 0) {
                            this.x = pipeRect.x + pipeRect.width;
                        }
                    }
                });

                // „Éñ„É≠„ÉÉ„ÇØ„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆöÔºàÊ®™Ôºâ
                blocks.forEach(block => {
                    const blockRect = block.getRect();
                    const playerRect = this.getRect();

                    if (this.checkCollision(playerRect, blockRect)) {
                        if (this.velocityX > 0) {
                            this.x = blockRect.x - this.width;
                        } else if (this.velocityX < 0) {
                            this.x = blockRect.x + blockRect.width;
                        }
                    }
                });

                // ÁîªÈù¢Â∑¶Á´Ø„ÅÆÂà∂Èôê
                if (this.x < 0) {
                    this.x = 0;
                }

                // ‰ΩçÁΩÆÊõ¥Êñ∞ÔºàYËª∏Ôºâ
                this.y += this.velocityY;

                // Âú∞Èù¢„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆö
                this.isOnGround = false;
                if (this.y + this.height >= GROUND_Y) {
                    this.y = GROUND_Y - this.height;
                    this.velocityY = 0;
                    this.isOnGround = true;
                }

                // „Éñ„É≠„ÉÉ„ÇØ„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆöÔºà‰∏ä‰∏ãÔºâ
                blocks.forEach(block => {
                    const blockRect = block.getRect();
                    const playerRect = this.getRect();

                    if (this.checkCollision(playerRect, blockRect)) {
                        if (this.velocityY > 0) {
                            // ‰∏ã„Å´ÁßªÂãï‰∏≠Ôºà„Éñ„É≠„ÉÉ„ÇØ„ÅÆ‰∏ä„Å´ÁùÄÂú∞Ôºâ
                            this.y = blockRect.y - this.height;
                            this.velocityY = 0;
                            this.isOnGround = true;
                        } else if (this.velocityY < 0) {
                            // ‰∏ä„Å´ÁßªÂãï‰∏≠Ôºà„Éñ„É≠„ÉÉ„ÇØ„ÅÆ‰∏ã„Å´È†≠„Çí„Å∂„Å§„Åë„ÇãÔºâ
                            this.y = blockRect.y + blockRect.height;
                            this.velocityY = 0;
                            block.hit();
                        }
                    }
                });

                // „Éë„Ç§„Éó„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆöÔºà‰∏äÔºâ
                pipes.forEach(pipe => {
                    const pipeRect = pipe.getRect();
                    const playerRect = this.getRect();

                    if (this.checkCollision(playerRect, pipeRect)) {
                        if (this.velocityY > 0) {
                            this.y = pipeRect.y - this.height;
                            this.velocityY = 0;
                            this.isOnGround = true;
                        }
                    }
                });

                // „Ç´„É°„É©ËøΩÂæìÔºàÂ∑¶Âè≥‰∏°ÊñπÂêë„Å´ÂØæÂøúÔºâ
                const playerScreenX = this.x - cameraX;
                const centerX = canvas.width / 2;
                const deadZone = 100; // „Ç´„É°„É©„ÅåÂãï„ÅçÂßã„ÇÅ„Çã„Åæ„Åß„ÅÆÁØÑÂõ≤

                // „Éó„É¨„Ç§„É§„Éº„ÅåÁîªÈù¢‰∏≠Â§Æ„Çà„ÇäÂè≥„Å´„ÅÑ„ÇãÂ†¥Âêà
                if (playerScreenX > centerX + deadZone) {
                    cameraX = this.x - centerX - deadZone;
                }
                // „Éó„É¨„Ç§„É§„Éº„ÅåÁîªÈù¢‰∏≠Â§Æ„Çà„ÇäÂ∑¶„Å´„ÅÑ„ÇãÂ†¥Âêà
                else if (playerScreenX < centerX - deadZone) {
                    cameraX = this.x - centerX + deadZone;
                }

                // „Ç´„É°„É©„ÅÆÂ∑¶Á´ØÂà∂Èôê
                if (cameraX < 0) {
                    cameraX = 0;
                }
            }

            draw() {
                const screenX = this.x - cameraX;

                // ÁÑ°Êïµ‰∏≠„ÅØÁÇπÊªÖ„Åï„Åõ„Çã
                if (this.invincible && Math.floor(this.invincibleTimer / 5) % 2 === 0) {
                    return; // ÁÇπÊªÖ„ÅÆ„Åü„ÇÅÊèèÁîª„Çí„Çπ„Ç≠„ÉÉ„Éó
                }

                ctx.save();

                // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®
                const walkCycle = Math.sin(animationFrame * 0.3);
                const legOffset = this.velocityX !== 0 ? walkCycle * 3 : 0;
                const armSwing = this.velocityX !== 0 ? walkCycle * 4 : 0;
                const isJumpPose = !this.isOnGround;

                // „Çµ„Ç§„Ç∫„Å´Âøú„Åò„Åü„Çπ„Ç±„Éº„É´
                const scale = this.width / this.normalWidth;
                const baseY = this.y + this.height;

                // === „Äå3-2G„ÄçÁ∏¶Êõ∏„ÅçÊñáÂ≠óÊú¨‰Ωì ===
                // ÊñáÂ≠ó„ÇíÁ∏¶„Å´ÈÖçÁΩÆ
                const chars = ['3', '-', '2', 'G'];
                const charHeight = this.height / chars.length;
                const fontSize = Math.floor(charHeight * 0.9); // „Çà„ÇäÂ§ß„Åç„Åè
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // ÂêÑÊñáÂ≠ó„ÇíÊèèÁîª
                chars.forEach((char, index) => {
                    const charY = this.y + charHeight * index + charHeight / 2;

                    // ÊñáÂ≠ó„ÅÆÂΩ±Ôºà„Çà„ÇäÊøÉ„ÅèÔºâ
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillText(char, screenX + this.width / 2 + 3 * scale, charY + 3 * scale);

                    // ÊñáÂ≠ó„ÅÆ„Ç¢„Ç¶„Éà„É©„Ç§„É≥Ôºà„Çà„ÇäÂ§™„Åè„ÄÅÊøÉ„ÅÑËâ≤Ôºâ
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 6 * scale;
                    ctx.lineJoin = 'round';
                    ctx.strokeText(char, screenX + this.width / 2, charY);

                    // ÊñáÂ≠óÊú¨‰ΩìÔºà„Çà„ÇäÊòé„Çã„ÅÑËâ≤Ôºâ
                    ctx.fillStyle = '#FFD700'; // ÈáëËâ≤„ÅßÁõÆÁ´ã„Å§„Çà„ÅÜ„Å´
                    ctx.fillText(char, screenX + this.width / 2, charY);
                });

                // === Ë∂≥Ôºà„Ç∑„É≥„Éó„É´Ôºâ ===
                const legWidth = 4 * scale;
                const legHeight = 6 * scale; // 8‚Üí6„Å´Áü≠Á∏Æ
                const footSize = 6 * scale;
                const legStartY = baseY - legHeight; // Ë∂≥„Çí‰Ωì„ÅÆÂÜÖÂÅ¥„Åã„ÇâÊèèÁîª

                ctx.fillStyle = '#2c3e50';

                if (isJumpPose) {
                    // „Ç∏„É£„É≥„ÉóÊôÇÔºöË∂≥„ÇíÊèÉ„Åà„Çã
                    ctx.fillRect(screenX + this.width * 0.35, legStartY, legWidth, legHeight);
                    ctx.fillRect(screenX + this.width * 0.6, legStartY, legWidth, legHeight);

                    // Èù¥
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(screenX + this.width * 0.35 - 2, baseY, footSize, 2 * scale);
                    ctx.fillRect(screenX + this.width * 0.6 - 2, baseY, footSize, 2 * scale);
                } else {
                    // Ê≠©Ë°åÊôÇÔºöË∂≥„ÇíÂãï„Åã„Åô
                    ctx.fillRect(screenX + this.width * 0.35, legStartY + legOffset, legWidth, legHeight);
                    ctx.fillRect(screenX + this.width * 0.6, legStartY - legOffset, legWidth, legHeight);

                    // Èù¥
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(screenX + this.width * 0.35 - 2, baseY + legOffset, footSize, 2 * scale);
                    ctx.fillRect(screenX + this.width * 0.6 - 2, baseY - legOffset, footSize, 2 * scale);
                }


                ctx.restore();
            }

            startFalling() {
                this.isFalling = true;
                this.velocityY = -8; // Â∞ë„Åó‰∏ä„Å´Ë∑≥„Å≠„Çã
            }

            startHitAnimation(enemyX) {
                this.isHit = true;
                this.velocityY = -10; // ‰∏ä„Å´Ë∑≥„Å≠„Çã
                // Êïµ„ÅÆ‰ΩçÁΩÆ„Å´Âøú„Åò„Å¶„Éé„ÉÉ„ÇØ„Éê„ÉÉ„ÇØÊñπÂêë„ÇíÊ±∫ÂÆö
                this.hitKnockbackX = this.x < enemyX ? -3 : 3;
            }

            powerUp() {
                if (!this.isPoweredUp) {
                    this.isPoweredUp = true;
                    this.powerUpAnimation = 30; // 30„Éï„É¨„Éº„É†„Åß„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                }
            }

            powerDown() {
                if (this.isPoweredUp) {
                    this.isPoweredUp = false;
                    this.powerUpAnimation = 30;
                    this.invincible = true;
                    this.invincibleTimer = 120; // 2ÁßíÈñìÁÑ°ÊïµÔºà60fps x 2Ôºâ
                }
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }

            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
        }

        // „Éú„Çπ„ÇØ„É©„Çπ
        class Boss {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 80;
                this.height = 80;
                this.velocityX = -3;
                this.velocityY = 0;
                this.isAlive = true;
                this.maxHp = 5;
                this.hp = this.maxHp;
                this.isJumping = false;
                this.jumpTimer = 0;
                this.hitFlash = 0; // „ÉÄ„É°„Éº„Ç∏ÁÇπÊªÖÁî®
            }

            update(blocks, pipes, pits) {
                if (!this.isAlive) return;

                // Á©¥„ÅÆÊâãÂâç„Åß„ÉÅ„Çß„ÉÉ„ÇØ
                let nearPit = false;
                if (pits) {
                    pits.forEach(pit => {
                        const checkDistance = 50;
                        if (this.velocityX > 0) {
                            if (this.x + this.width + checkDistance > pit.x && this.x < pit.x) {
                                nearPit = true;
                            }
                        } else {
                            if (this.x - checkDistance < pit.x + pit.width && this.x > pit.x + pit.width) {
                                nearPit = true;
                            }
                        }
                    });
                }

                if (nearPit) {
                    this.velocityX *= -1;
                }

                // Â∑¶Âè≥ÁßªÂãï
                this.x += this.velocityX;

                // „Ç∏„É£„É≥„ÉóÔºàÂÆöÊúüÁöÑ„Å´Ôºâ
                this.jumpTimer++;
                if (this.jumpTimer > 120 && !this.isJumping) {
                    this.velocityY = -12;
                    this.isJumping = true;
                    this.jumpTimer = 0;
                }

                // ÈáçÂäõ
                this.velocityY += GRAVITY;
                this.y += this.velocityY;

                // Âú∞Èù¢„Å®„ÅÆË°ùÁ™Å
                if (this.y + this.height >= GROUND_Y) {
                    this.y = GROUND_Y - this.height;
                    this.velocityY = 0;
                    this.isJumping = false;
                }

                // „Éñ„É≠„ÉÉ„ÇØ„Å®„ÅÆË°ùÁ™Å
                blocks.forEach(block => {
                    const blockRect = block.getRect();
                    const bossRect = this.getRect();
                    if (this.checkCollision(bossRect, blockRect)) {
                        if (this.y + this.height <= blockRect.y + 10) {
                            this.y = blockRect.y - this.height;
                            this.velocityY = 0;
                            this.isJumping = false;
                        } else {
                            this.velocityX *= -1;
                        }
                    }
                });

                // „Éë„Ç§„Éó„Å®„ÅÆË°ùÁ™Å
                pipes.forEach(pipe => {
                    const pipeRect = pipe.getRect();
                    const bossRect = this.getRect();
                    if (this.checkCollision(bossRect, pipeRect)) {
                        this.velocityX *= -1;
                    }
                });

                // ÁßªÂãïÁØÑÂõ≤Âà∂ÈôêÔºà„Ç¥„Éº„É´Âë®Ëæ∫Ôºâ
                if (this.x < 4000 || this.x > 4400) {
                    this.velocityX *= -1;
                }

                // „ÉÄ„É°„Éº„Ç∏ÁÇπÊªÖ
                if (this.hitFlash > 0) {
                    this.hitFlash--;
                }
            }

            draw() {
                if (!this.isAlive) return;

                const screenX = this.x - cameraX;
                const walkFrame = Math.floor(animationFrame / 10) % 2;

                // „ÉÄ„É°„Éº„Ç∏ÁÇπÊªÖ
                if (this.hitFlash > 0 && Math.floor(this.hitFlash / 5) % 2 === 0) {
                    return; // ÁÇπÊªÖ„Åï„Åõ„Çã„Åü„ÇÅ„Å´‰∏ÄÊôÇÁöÑ„Å´ÈùûË°®Á§∫
                }

                // ÂΩ±
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, GROUND_Y + 2, this.width / 2, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // ‰ΩìÔºàÂ∑®Â§ß„Å™„Åç„ÅÆ„Åì„É¢„É≥„Çπ„Çø„ÉºÔºâ
                // ‰Ωì„ÅÆÈÉ®ÂàÜ
                ctx.fillStyle = '#8B0000'; // „ÉÄ„Éº„ÇØ„É¨„ÉÉ„Éâ
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, this.y + 40, 35, 30, 0, 0, Math.PI * 2);
                ctx.fill();

                // ÂÇò„ÅÆÈÉ®ÂàÜÔºàËµ§„Å®Èªí„ÅÆ„Éâ„ÉÉ„ÉàÔºâ
                ctx.fillStyle = '#DC143C'; // „ÇØ„É™„É†„Çæ„É≥
                ctx.beginPath();
                ctx.arc(screenX + 15, this.y + 15, 8, 0, Math.PI * 2);
                ctx.arc(screenX + 40, this.y + 10, 10, 0, Math.PI * 2);
                ctx.arc(screenX + 65, this.y + 15, 8, 0, Math.PI * 2);
                ctx.fill();

                // ÁéãÂÜ†
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.moveTo(screenX + 20, this.y - 5);
                ctx.lineTo(screenX + 25, this.y - 15);
                ctx.lineTo(screenX + 30, this.y - 8);
                ctx.lineTo(screenX + 35, this.y - 15);
                ctx.lineTo(screenX + 40, this.y - 8);
                ctx.lineTo(screenX + 45, this.y - 15);
                ctx.lineTo(screenX + 50, this.y - 8);
                ctx.lineTo(screenX + 55, this.y - 15);
                ctx.lineTo(screenX + 60, this.y - 5);
                ctx.closePath();
                ctx.fill();

                // ÁéãÂÜ†„ÅÆÂÆùÁü≥
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(screenX + 25, this.y - 12, 3, 0, Math.PI * 2);
                ctx.arc(screenX + 40, this.y - 12, 3, 0, Math.PI * 2);
                ctx.arc(screenX + 55, this.y - 12, 3, 0, Math.PI * 2);
                ctx.fill();

                // ÁõÆÔºàÂ§ß„Åç„ÅèÂ®ÅÂúßÁöÑÔºâ
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(screenX + 25, this.y + 35, 10, 0, Math.PI * 2);
                ctx.arc(screenX + 55, this.y + 35, 10, 0, Math.PI * 2);
                ctx.fill();

                // ÈªíÁõÆÔºàÊÄí„Å£„ÅüË°®ÊÉÖÔºâ
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(screenX + 26, this.y + 37, 6, 0, Math.PI * 2);
                ctx.arc(screenX + 56, this.y + 37, 6, 0, Math.PI * 2);
                ctx.fill();

                // ÁúâÊØõÔºàÊÄí„ÇäÔºâ
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(screenX + 15, this.y + 25);
                ctx.lineTo(screenX + 30, this.y + 30);
                ctx.moveTo(screenX + 65, this.y + 25);
                ctx.lineTo(screenX + 50, this.y + 30);
                ctx.stroke();

                // Âè£ÔºàÂ§ß„Åç„ÅèÈñã„ÅÑ„ÅüÔºâ
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, this.y + 55, 15, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // Áâô
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(screenX + 30, this.y + 50);
                ctx.lineTo(screenX + 25, this.y + 60);
                ctx.lineTo(screenX + 35, this.y + 55);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(screenX + 50, this.y + 50);
                ctx.lineTo(screenX + 55, this.y + 60);
                ctx.lineTo(screenX + 45, this.y + 55);
                ctx.closePath();
                ctx.fill();

                // Ë∂≥ÔºàÊ≠©Ë°å„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ôºâ
                ctx.fillStyle = '#654321';
                const footOffset = walkFrame === 0 ? 0 : 5;
                ctx.fillRect(screenX + 20 - footOffset, this.y + 70, 15, 10);
                ctx.fillRect(screenX + 45 + footOffset, this.y + 70, 15, 10);

                // HP„Éê„Éº
                const barWidth = this.width;
                const barHeight = 8;
                const barX = screenX;
                const barY = this.y - 20;

                // HP„Éê„ÉºËÉåÊôØ
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // HPÔºàÁèæÂú®ÂÄ§Ôºâ
                const hpRatio = this.hp / this.maxHp;
                ctx.fillStyle = hpRatio > 0.5 ? '#2ecc71' : hpRatio > 0.2 ? '#f39c12' : '#e74c3c';
                ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);

                // HP„Éê„ÉºÊû†
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);

                // „ÄåBOSS„Äç„ÅÆÊñáÂ≠ó
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BOSS', screenX + this.width / 2, barY - 5);
            }

            takeDamage() {
                this.hp--;
                this.hitFlash = 20; // 20„Éï„É¨„Éº„É†ÁÇπÊªÖ
                if (this.hp <= 0) {
                    this.isAlive = false;
                }
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }

            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
        }

        // Êïµ„ÇØ„É©„ÇπÔºà„É™„Ç¢„É´ÁâàÔºâ
        class Enemy {
            constructor(x, y, type) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.velocityX = -1.5; // „Çπ„Éî„Éº„Éâ„ÇíÈÅÖ„Åè
                this.isAlive = true;
                this.state = 'walking';
                this.shellVelocity = 0;
            }

            update(blocks, pipes, pits) {
                if (!this.isAlive) return;

                if (this.type === 'goomba') {
                    // Á©¥„Å®„Éë„Ç§„Éó„ÅÆÊâãÂâç„Åß„ÉÅ„Çß„ÉÉ„ÇØÔºàÈÄ≤Ë°åÊñπÂêëÔºâ
                    let shouldTurn = false;

                    // Á©¥„ÉÅ„Çß„ÉÉ„ÇØ
                    if (pits) {
                        pits.forEach(pit => {
                            const checkDistance = 30;
                            if (this.velocityX > 0) {
                                if (this.x + this.width + checkDistance > pit.x &&
                                    this.x < pit.x) {
                                    shouldTurn = true;
                                }
                            } else {
                                if (this.x - checkDistance < pit.x + pit.width &&
                                    this.x > pit.x + pit.width) {
                                    shouldTurn = true;
                                }
                            }
                        });
                    }

                    // „Éë„Ç§„Éó„ÉÅ„Çß„ÉÉ„ÇØÔºàÊé•ËøëÂâç„Å´ÊñπÂêëËª¢ÊèõÔºâ
                    if (pipes) {
                        pipes.forEach(pipe => {
                            const pipeRect = pipe.getRect();
                            const checkDistance = 50;
                            if (this.velocityX > 0) {
                                // Âè≥„Å´ÈÄ≤„Çì„Åß„ÅÑ„ÇãÂ†¥Âêà„ÄÅ„Éë„Ç§„Éó„ÅÆÂ∑¶ÂÅ¥„Åß„ÉÅ„Çß„ÉÉ„ÇØ
                                if (this.x + this.width + checkDistance > pipeRect.x &&
                                    this.x < pipeRect.x) {
                                    shouldTurn = true;
                                }
                            } else {
                                // Â∑¶„Å´ÈÄ≤„Çì„Åß„ÅÑ„ÇãÂ†¥Âêà„ÄÅ„Éë„Ç§„Éó„ÅÆÂè≥ÂÅ¥„Åß„ÉÅ„Çß„ÉÉ„ÇØ
                                if (this.x - checkDistance < pipeRect.x + pipeRect.width &&
                                    this.x > pipeRect.x + pipeRect.width) {
                                    shouldTurn = true;
                                }
                            }
                        });
                    }

                    // ÊñπÂêëËª¢Êèõ
                    if (shouldTurn) {
                        this.velocityX *= -1;
                    }

                    this.x += this.velocityX;

                    let onGround = false;
                    if (this.y + this.height < GROUND_Y) {
                        this.y += GRAVITY;
                    } else {
                        this.y = GROUND_Y - this.height;
                        onGround = true;
                    }

                    blocks.forEach(block => {
                        const blockRect = block.getRect();
                        const enemyRect = this.getRect();
                        if (this.checkCollision(enemyRect, blockRect)) {
                            if (this.y + this.height <= blockRect.y + 10) {
                                this.y = blockRect.y - this.height;
                                onGround = true;
                            } else {
                                this.velocityX *= -1;
                            }
                        }
                    });

                    pipes.forEach(pipe => {
                        const pipeRect = pipe.getRect();
                        const enemyRect = this.getRect();
                        if (this.checkCollision(enemyRect, pipeRect)) {
                            this.velocityX *= -1;
                        }
                    });

                    if (this.x < 0 || this.x > 3000) {
                        this.velocityX *= -1;
                    }
                }

                if (this.type === 'koopa') {
                    if (this.state === 'walking') {
                        // Á©¥„Å®„Éë„Ç§„Éó„ÅÆÊâãÂâç„Åß„ÉÅ„Çß„ÉÉ„ÇØ
                        let shouldTurn = false;

                        // Á©¥„ÉÅ„Çß„ÉÉ„ÇØ
                        if (pits) {
                            pits.forEach(pit => {
                                const checkDistance = 30;
                                if (this.velocityX > 0) {
                                    if (this.x + this.width + checkDistance > pit.x &&
                                        this.x < pit.x) {
                                        shouldTurn = true;
                                    }
                                } else {
                                    if (this.x - checkDistance < pit.x + pit.width &&
                                        this.x > pit.x + pit.width) {
                                        shouldTurn = true;
                                    }
                                }
                            });
                        }

                        // „Éë„Ç§„Éó„ÉÅ„Çß„ÉÉ„ÇØ
                        if (pipes) {
                            pipes.forEach(pipe => {
                                const pipeRect = pipe.getRect();
                                const checkDistance = 50;
                                if (this.velocityX > 0) {
                                    if (this.x + this.width + checkDistance > pipeRect.x &&
                                        this.x < pipeRect.x) {
                                        shouldTurn = true;
                                    }
                                } else {
                                    if (this.x - checkDistance < pipeRect.x + pipeRect.width &&
                                        this.x > pipeRect.x + pipeRect.width) {
                                        shouldTurn = true;
                                    }
                                }
                            });
                        }

                        // ÊñπÂêëËª¢Êèõ
                        if (shouldTurn) {
                            this.velocityX *= -1;
                        }

                        this.x += this.velocityX;

                        if (this.y + this.height < GROUND_Y) {
                            this.y += GRAVITY;
                        } else {
                            this.y = GROUND_Y - this.height;
                        }

                        blocks.forEach(block => {
                            const blockRect = block.getRect();
                            const enemyRect = this.getRect();
                            if (this.checkCollision(enemyRect, blockRect)) {
                                if (this.y + this.height <= blockRect.y + 10) {
                                    this.y = blockRect.y - this.height;
                                } else {
                                    this.velocityX *= -1;
                                }
                            }
                        });

                        pipes.forEach(pipe => {
                            const pipeRect = pipe.getRect();
                            const enemyRect = this.getRect();
                            if (this.checkCollision(enemyRect, pipeRect)) {
                                this.velocityX *= -1;
                            }
                        });

                        if (this.x < 0 || this.x > 3000) {
                            this.velocityX *= -1;
                        }
                    } else if (this.state === 'shell') {
                        this.height = 30;
                        this.y = GROUND_Y - this.height;
                    } else if (this.state === 'shellMoving') {
                        this.x += this.shellVelocity;
                        this.height = 30;

                        // Á©¥„Å´ËêΩ„Å°„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºàÁî≤ÁæÖ„ÇíÊ∂à„ÅôÔºâ
                        if (pits) {
                            pits.forEach(pit => {
                                if (this.x + this.width / 2 > pit.x &&
                                    this.x + this.width / 2 < pit.x + pit.width &&
                                    this.y + this.height >= GROUND_Y) {
                                    this.isAlive = false; // Áî≤ÁæÖ„ÇíÊ∂à„Åô
                                }
                            });
                        }

                        // „Éë„Ç§„Éó„Å´ÂΩì„Åü„Å£„Åü„ÇâË∑≥„Å≠Ëøî„Çã
                        pipes.forEach(pipe => {
                            const pipeRect = pipe.getRect();
                            const enemyRect = this.getRect();
                            if (this.checkCollision(enemyRect, pipeRect)) {
                                // Ë∑≥„Å≠Ëøî„Çã
                                this.shellVelocity *= -1;
                                // „Éë„Ç§„Éó„Åã„ÇâÈõ¢„ÅôÔºà„ÇÅ„ÇäËæº„ÅøÈò≤Ê≠¢Ôºâ
                                if (this.shellVelocity > 0) {
                                    this.x = pipeRect.x + pipeRect.width + 2;
                                } else {
                                    this.x = pipeRect.x - this.width - 2;
                                }
                            }
                        });
                    }
                }
            }

            draw() {
                if (!this.isAlive) return;

                const screenX = this.x - cameraX;
                const walkFrame = Math.floor(animationFrame / 10) % 2;

                if (this.type === 'goomba') {
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.ellipse(screenX + this.width / 2, this.y + 20, 18, 16, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#A0522D';
                    ctx.beginPath();
                    ctx.arc(screenX + 10, this.y + 8, 4, 0, Math.PI * 2);
                    ctx.arc(screenX + 30, this.y + 8, 4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(screenX + 12, this.y + 18, 6, 0, Math.PI * 2);
                    ctx.arc(screenX + 28, this.y + 18, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(screenX + 13, this.y + 19, 3, 0, Math.PI * 2);
                    ctx.arc(screenX + 29, this.y + 19, 3, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(screenX + 8, this.y + 14);
                    ctx.lineTo(screenX + 16, this.y + 16);
                    ctx.moveTo(screenX + 32, this.y + 14);
                    ctx.lineTo(screenX + 24, this.y + 16);
                    ctx.stroke();

                    ctx.fillStyle = '#654321';
                    const footOffset = walkFrame === 0 ? 0 : 3;
                    ctx.fillRect(screenX + 10 - footOffset, this.y + 36, 8, 4);
                    ctx.fillRect(screenX + 22 + footOffset, this.y + 36, 8, 4);
                }

                if (this.type === 'koopa') {
                    if (this.state === 'walking') {
                        ctx.fillStyle = '#2ecc71';
                        ctx.beginPath();
                        ctx.ellipse(screenX + 20, this.y + 15, 18, 14, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.strokeStyle = '#27ae60';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(screenX + 20, this.y + 15, 14, 0, Math.PI * 2);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(screenX + 20, this.y + 8);
                        ctx.lineTo(screenX + 20, this.y + 22);
                        ctx.moveTo(screenX + 12, this.y + 15);
                        ctx.lineTo(screenX + 28, this.y + 15);
                        ctx.stroke();

                        ctx.fillStyle = '#f39c12';
                        ctx.beginPath();
                        const headDir = this.velocityX > 0 ? -8 : 8;
                        ctx.arc(screenX + 20 + headDir, this.y + 8, 8, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(screenX + 20 + headDir - 2, this.y + 7, 3, 0, Math.PI * 2);
                        ctx.arc(screenX + 20 + headDir + 2, this.y + 7, 3, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(screenX + 20 + headDir - 2, this.y + 7, 1.5, 0, Math.PI * 2);
                        ctx.arc(screenX + 20 + headDir + 2, this.y + 7, 1.5, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = '#e67e22';
                        const footOffset = walkFrame === 0 ? 0 : 4;
                        ctx.fillRect(screenX + 8 - footOffset, this.y + 28, 10, 12);
                        ctx.fillRect(screenX + 22 + footOffset, this.y + 28, 10, 12);

                        ctx.strokeStyle = '#f39c12';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        const tailDir = this.velocityX > 0 ? 1 : -1;
                        ctx.moveTo(screenX + 20 - tailDir * 18, this.y + 20);
                        ctx.lineTo(screenX + 20 - tailDir * 24, this.y + 18);
                        ctx.stroke();
                    } else {
                        // Áî≤ÁæÖÁä∂ÊÖãÔºà‰∫Ä„ÅÆÁî≤ÁæÖÈ¢®Ôºâ
                        const shellCenterX = screenX + this.width / 2;
                        const shellCenterY = this.y + this.height / 2;
                        const shellRadius = this.width / 2;

                        // Áî≤ÁæÖ„ÅÆÂΩ±
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.beginPath();
                        ctx.ellipse(shellCenterX, shellCenterY + 2, shellRadius, shellRadius * 0.8, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Áî≤ÁæÖÊú¨‰ΩìÔºàÊ•ïÂÜÜÂΩ¢Ôºâ
                        ctx.fillStyle = '#2ecc71';
                        ctx.beginPath();
                        ctx.ellipse(shellCenterX, shellCenterY, shellRadius, shellRadius * 0.8, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Áî≤ÁæÖ„ÅÆÁ∏ÅÂèñ„Çä
                        ctx.strokeStyle = '#27ae60';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.ellipse(shellCenterX, shellCenterY, shellRadius, shellRadius * 0.8, 0, 0, Math.PI * 2);
                        ctx.stroke();

                        // Áî≤ÁæÖ„ÅÆÊ®°ÊßòÔºàÂÖ≠ËßíÂΩ¢„Éë„Çø„Éº„É≥Ôºâ
                        ctx.strokeStyle = '#1e8449';
                        ctx.lineWidth = 2;

                        // ‰∏≠Â§Æ„ÅÆÂÖ≠ËßíÂΩ¢
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            const x = shellCenterX + Math.cos(angle) * 8;
                            const y = shellCenterY + Math.sin(angle) * 6;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.stroke();

                        // ‰∏≠Â§Æ„Åã„ÇâÊîæÂ∞ÑÁä∂„ÅÆÁ∑ö
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            ctx.beginPath();
                            ctx.moveTo(shellCenterX, shellCenterY);
                            ctx.lineTo(
                                shellCenterX + Math.cos(angle) * shellRadius * 0.7,
                                shellCenterY + Math.sin(angle) * shellRadius * 0.7 * 0.8
                            );
                            ctx.stroke();
                        }

                        // „Éè„Ç§„É©„Ç§„ÉàÔºàÁ´ã‰ΩìÊÑüÔºâ
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.beginPath();
                        ctx.ellipse(shellCenterX - 5, shellCenterY - 5, 8, 6, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Âãï„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÂõûËª¢„Ç®„Éï„Çß„ÇØ„Éà
                        if (this.state === 'shellMoving') {
                            const spinAngle = (animationFrame * 0.5) % (Math.PI * 2);
                            ctx.save();
                            ctx.translate(shellCenterX, shellCenterY);
                            ctx.rotate(spinAngle);

                            // ÂõûËª¢Á∑ö
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(-shellRadius * 0.5, 0);
                            ctx.lineTo(shellRadius * 0.5, 0);
                            ctx.stroke();

                            ctx.restore();
                        }
                    }
                }
            }

            stomp() {
                if (this.type === 'goomba') {
                    this.isAlive = false;
                    score += 200;
                    updateScore();
                } else if (this.type === 'koopa') {
                    if (this.state === 'walking') {
                        this.state = 'shell';
                        this.velocityX = 0;
                        this.y = GROUND_Y - 30;
                        score += 300;
                        updateScore();
                    }
                }
            }

            kickShell(direction) {
                if (this.type === 'koopa' && this.state === 'shell') {
                    this.state = 'shellMoving';
                    this.shellVelocity = direction > 0 ? 12 : -12;
                }
            }

            getRect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }

            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
        }

        // „Ç¥„Éº„É´ÔºàÊóóÔºâ„ÇØ„É©„Çπ
        class Goal {
            constructor(x) {
                this.x = x;
                this.y = GROUND_Y - 180;
                this.width = 20;
                this.height = 180;
                this.flagWidth = 60;
                this.flagHeight = 50;
            }

            draw() {
                const screenX = this.x - cameraX;

                ctx.fillStyle = '#666';
                ctx.fillRect(screenX, this.y, this.width, this.height);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(screenX + this.width / 2, this.y, this.width / 2, this.height);

                const flagY = this.y + Math.sin(animationFrame * 0.1) * 5;
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(screenX + this.width, flagY);
                ctx.lineTo(screenX + this.width + this.flagWidth, flagY + this.flagHeight / 2);
                ctx.lineTo(screenX + this.width, flagY + this.flagHeight);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = '#c0392b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenX + this.width, flagY);
                ctx.lineTo(screenX + this.width + this.flagWidth, flagY + this.flagHeight / 2);
                ctx.lineTo(screenX + this.width, flagY + this.flagHeight);
                ctx.closePath();
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚òÖ', screenX + this.width + this.flagWidth / 2, flagY + this.flagHeight / 2 + 8);
            }

            checkCollision(player) {
                return player.x + player.width >= this.x &&
                       player.x <= this.x + this.width + this.flagWidth;
            }
        }

        // ÂΩì„Åü„ÇäÂà§ÂÆöÈñ¢Êï∞
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // „Çπ„Ç≥„Ç¢Êõ¥Êñ∞
        function updateScore() {
            document.getElementById('scoreValue').textContent = score;
        }

        // „Ç≤„Éº„É†„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
        let player;
        let enemies;
        let blocks;
        let pipes;
        let pits;
        let goal;
        let items;
        let boss;

        function initGame() {
            player = new Player();
            score = 0;
            updateScore();

            // „Éñ„É≠„ÉÉ„ÇØ„ÅÆÈÖçÁΩÆÔºàÂøÖË¶ÅÊúÄÂ∞èÈôê„Å´Ë™øÊï¥Ôºâ
            blocks = [
                new Block(300, GROUND_Y - 120, 'question', 'coin'),
                new Block(380, GROUND_Y - 120, 'question', 'mushroom'),

                new Block(1050, GROUND_Y - 120, 'question', 'coin'),

                new Block(1380, GROUND_Y - 120, 'question', 'star'),

                new Block(2400, GROUND_Y - 120, 'question', 'mushroom'),

                new Block(2950, GROUND_Y - 200, 'question', 'star'),

                new Block(3640, GROUND_Y - 120, 'question', 'coin'),

                new Block(4180, GROUND_Y - 150, 'question', 'mushroom')
            ];

            pipes = [
                new Pipe(620, 60),
                new Pipe(970, 80),
                new Pipe(1580, 100),
                new Pipe(1900, 80),
                // ËøΩÂä†„Éë„Ç§„Éó
                new Pipe(2600, 70),
                new Pipe(3100, 90),
                new Pipe(3650, 80), // 3500‚Üí3650 (Á©¥3450-3570„ÇíÈÅø„Åë„Çã)
                new Pipe(4150, 100) // 3900‚Üí4150 (Á©¥4000-4100„ÇíÈÅø„Åë„Çã)
            ];

            pits = [
                new Pit(1200, 120),
                new Pit(1800, 80),
                new Pit(2300, 100),
                // ËøΩÂä†Á©¥
                new Pit(2850, 100),
                new Pit(3450, 120),
                new Pit(4000, 100)
            ];

            enemies = [
                new Enemy(450, GROUND_Y - 40, 'goomba'),
                new Enemy(750, GROUND_Y - 40, 'koopa'),  // „Éë„Ç§„Éó620„Åã„ÇâÈõ¢„Åô
                new Enemy(1100, GROUND_Y - 40, 'goomba'), // „Éë„Ç§„Éó970„Åã„ÇâÈõ¢„Åô
                new Enemy(1350, GROUND_Y - 40, 'goomba'),
                new Enemy(1750, GROUND_Y - 40, 'koopa'),  // „Éë„Ç§„Éó1580„Å®1900„ÅÆÈñì
                new Enemy(2050, GROUND_Y - 40, 'goomba'), // „Éë„Ç§„Éó1900„ÅÆÂæå
                new Enemy(2400, GROUND_Y - 40, 'koopa'),  // „Éë„Ç§„Éó2600„ÅÆÊâãÂâç
                new Enemy(2750, GROUND_Y - 40, 'goomba'), // „Éë„Ç§„Éó2600„ÅÆÂæå„ÄÅÁ©¥2850„ÅÆÊâãÂâç
                new Enemy(2950, GROUND_Y - 40, 'koopa'),  // Á©¥2850„ÅÆÂæå„ÄÅ„Éë„Ç§„Éó3100„ÅÆÊâãÂâç
                new Enemy(3250, GROUND_Y - 40, 'goomba'), // „Éë„Ç§„Éó3100„ÅÆÂæå„ÄÅÁ©¥3450„ÅÆÊâãÂâç
                new Enemy(3800, GROUND_Y - 40, 'koopa'),  // Á©¥3450„ÅÆÂæå„ÄÅ„Éë„Ç§„Éó3650„ÅÆÂæå
                new Enemy(4300, GROUND_Y - 40, 'goomba')  // „Éë„Ç§„Éó4150„ÅÆÂæå
            ];

            items = [];

            // „Éú„ÇπÔºà„Ç¥„Éº„É´ÊâãÂâçÔºâ
            boss = new Boss(4200, GROUND_Y - 80);

            goal = new Goal(4500);

            gameState = 'playing';
            cameraX = 0;
            animationFrame = 0;

            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('gameClear').style.display = 'none';
        }

        // „Ç≤„Éº„É†„É´„Éº„Éó
        function gameLoop() {
            animationFrame++;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // „Çø„Ç§„Éà„É´ÁîªÈù¢„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø„Ç≤„Éº„É†ÁîªÈù¢„ÇíÊèèÁîª
            if (gameState !== 'title') {
                // ËÉåÊôØË£ÖÈ£æÔºàÈõ≤Ôºâ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                drawCloud(200 - (cameraX * 0.2) % 400, 80);
                drawCloud(500 - (cameraX * 0.2) % 400, 120);
                drawCloud(800 - (cameraX * 0.2) % 400, 60);

                // Âú∞Èù¢ÊèèÁîª
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(0, GROUND_Y, canvas.width, GROUND_HEIGHT);

                ctx.fillStyle = '#27ae60';
                ctx.fillRect(0, GROUND_Y, canvas.width, 8);

                ctx.fillStyle = '#654321';
                for (let i = 0; i < canvas.width; i += 40) {
                    ctx.fillRect(i, GROUND_Y + 20, 20, 20);
                }

                pits.forEach(pit => pit.draw());
                pipes.forEach(pipe => pipe.draw());
                blocks.forEach(block => block.draw());

                // „Ç¢„Ç§„ÉÜ„É†„ÅÆÊõ¥Êñ∞„Å®ÊèèÁîª
                items.forEach(item => {
                    item.update();
                    item.draw();
                });
            }

            if (gameState === 'playing' || gameState === 'falling' || gameState === 'hit') {
                player.update(blocks, pipes);

                // „Éí„ÉÉ„Éà„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥‰∏≠„Å´„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                if (gameState === 'hit' && player.y > canvas.height + 100) {
                    gameState = 'gameOver';
                    document.getElementById('gameOverReason').textContent = gameOverReason;
                    document.getElementById('gameOver').style.display = 'block';
                }

                // „Éí„ÉÉ„ÉàÁä∂ÊÖã„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøË°ùÁ™ÅÂà§ÂÆö„ÇíË°å„ÅÜ
                if (gameState !== 'hit') {
                    // „Ç¢„Ç§„ÉÜ„É†„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆö
                    items.forEach(item => {
                        if (!item.isCollected) {
                            const playerRect = player.getRect();
                            const itemRect = item.getRect();
                            if (checkCollision(playerRect, itemRect)) {
                                item.collect(player);
                            }
                        }
                    });

                    // Á©¥„Å´ËêΩ„Å°„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                    if (!player.isFalling) {
                        pits.forEach(pit => {
                            if (pit.checkFall(player)) {
                                gameState = 'falling';
                                player.startFalling();
                            }
                        });
                    }
                }

                // „Éú„ÇπÊõ¥Êñ∞
                if (boss) {
                    boss.update(blocks, pipes, pits);

                    if (gameState !== 'hit' && boss.isAlive) {
                        const playerRect = player.getRect();
                        const bossRect = boss.getRect();

                        // „Éú„Çπ„ÅÆÂΩì„Åü„ÇäÂà§ÂÆö„ÇÇÂ∞ë„ÅóÂ∞è„Åï„Åè„Åô„Çã
                        const bossHitbox = {
                            x: bossRect.x + 8,
                            y: bossRect.y + 8,
                            width: bossRect.width - 16,
                            height: bossRect.height - 16
                        };

                        if (checkCollision(playerRect, bossHitbox)) {
                            // „Éú„Çπ„ÅÆË∏è„Åø„Å§„ÅëÂà§ÂÆö„ÇíÂÑ™„Åó„ÅèÔºà‰∏äÈÉ®50%„Åæ„ÅßÔºâ
                            const isStompingFromAbove =
                                player.velocityY > 0 &&
                                playerRect.y + playerRect.height < bossRect.y + bossRect.height * 0.5;

                            if (isStompingFromAbove) {
                                // „Éú„Çπ„Å´„ÉÄ„É°„Éº„Ç∏
                                boss.takeDamage();
                                player.velocityY = JUMP_POWER / 2;
                                score += 500;
                                updateScore();
                            } else {
                                // „Éó„É¨„Ç§„É§„Éº„Åå„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„ÇãÔºàÁÑ°Êïµ‰∏≠„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÔºâ
                                if (!player.invincible) {
                                    if (player.isPoweredUp) {
                                        player.powerDown();
                                    } else {
                                        gameState = 'hit';
                                        gameOverReason = '„Éú„Çπ„Å´„ÇÑ„Çâ„Çå„Åæ„Åó„Åü';
                                        player.startHitAnimation(boss.x + boss.width / 2);
                                    }
                                }
                            }
                        }
                    }
                }

                // ÊïµÊõ¥Êñ∞
                enemies.forEach(enemy => {
                    enemy.update(blocks, pipes, pits);
                });

                // Âãï„ÅÑ„Å¶„ÅÑ„ÇãÁî≤ÁæÖ„Å®‰ªñ„ÅÆÊïµ„ÅÆË°ùÁ™ÅÂà§ÂÆö
                enemies.forEach((shell, shellIndex) => {
                    if (!shell.isAlive || shell.type !== 'koopa' || shell.state !== 'shellMoving') return;

                    const shellRect = shell.getRect();

                    enemies.forEach((enemy, enemyIndex) => {
                        if (shellIndex === enemyIndex || !enemy.isAlive) return;

                        const enemyRect = enemy.getRect();
                        if (checkCollision(shellRect, enemyRect)) {
                            // Áî≤ÁæÖ„Åå‰ªñ„ÅÆÊïµ„ÇíÂÄí„Åô
                            enemy.isAlive = false;
                            score += 200;
                            updateScore();
                        }
                    });
                });

                // „Éó„É¨„Ç§„É§„Éº„Å®Êïµ„ÅÆË°ùÁ™ÅÂà§ÂÆö
                enemies.forEach(enemy => {
                    if (!enemy.isAlive || gameState === 'hit') return;

                    const playerRect = player.getRect();
                    const enemyRect = enemy.getRect();

                    // ÂΩì„Åü„ÇäÂà§ÂÆö„ÇíÂ∞ë„ÅóÂ∞è„Åï„Åè„Åó„Å¶‰ΩôË£ï„ÇíÊåÅ„Åü„Åõ„Çã
                    const enemyHitbox = {
                        x: enemyRect.x + 5,
                        y: enemyRect.y + 5,
                        width: enemyRect.width - 10,
                        height: enemyRect.height - 10
                    };

                    if (checkCollision(playerRect, enemyHitbox)) {
                        // Ë∏è„Åø„Å§„ÅëÂà§ÂÆö„ÇíÂÑ™„Åó„ÅèÔºàÊïµ„ÅÆ‰∏äÈÉ®60%„Åæ„ÅßÔºâ
                        const isStompingFromAbove =
                            player.velocityY > 0 &&
                            playerRect.y + playerRect.height - 15 < enemyRect.y + enemyRect.height * 0.6;

                        if (isStompingFromAbove) {
                            enemy.stomp();
                            player.velocityY = JUMP_POWER / 2;
                        } else {
                            if (enemy.type === 'koopa' && enemy.state === 'shell') {
                                const direction = player.x < enemy.x ? 1 : -1;
                                enemy.kickShell(direction);
                            } else if (enemy.type === 'koopa' && enemy.state === 'shellMoving') {
                                // Âãï„ÅÑ„Å¶„ÅÑ„ÇãÁî≤ÁæÖ„Å´ÂΩì„Åü„Å£„ÅüÂ†¥ÂêàÔºàÁÑ°Êïµ‰∏≠„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÔºâ
                                if (!player.invincible) {
                                    if (player.isPoweredUp) {
                                        player.powerDown(); // „Éë„ÉØ„Éº„ÉÄ„Ç¶„É≥
                                    } else {
                                        gameState = 'hit';
                                        gameOverReason = 'Áî≤ÁæÖ„Å´ÂΩì„Åü„Çä„Åæ„Åó„Åü';
                                        player.startHitAnimation(enemy.x + enemy.width / 2);
                                    }
                                }
                            } else if (enemy.state === 'walking' || enemy.type === 'goomba') {
                                // ÈÄöÂ∏∏„ÅÆÊïµ„Å´Ê®™„Åã„ÇâÂΩì„Åü„Å£„ÅüÂ†¥ÂêàÔºàÁÑ°Êïµ‰∏≠„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÔºâ
                                if (!player.invincible) {
                                    if (player.isPoweredUp) {
                                        player.powerDown(); // „Éë„ÉØ„Éº„ÉÄ„Ç¶„É≥
                                    } else {
                                        gameState = 'hit';
                                        gameOverReason = 'Êïµ„Å´ÂΩì„Åü„Çä„Åæ„Åó„Åü';
                                        player.startHitAnimation(enemy.x + enemy.width / 2);
                                    }
                                }
                            }
                        }
                    }
                });

                // „Ç¥„Éº„É´Âà§ÂÆö
                if (goal.checkCollision(player)) {
                    gameState = 'clear';
                    document.getElementById('finalScore').textContent = score;
                    document.getElementById('gameClear').style.display = 'block';
                }
            }

            // ÊèèÁîªÔºà„Ç≤„Éº„É†„ÅåÈñãÂßã„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆ„ÅøÔºâ
            if (gameState !== 'title') {
                player.draw();
                enemies.forEach(enemy => enemy.draw());
                if (boss) boss.draw();
                goal.draw();
            }

            requestAnimationFrame(gameLoop);
        }

        // Èõ≤„ÇíÊèèÁîª
        function drawCloud(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.arc(x + 25, y, 25, 0, Math.PI * 2);
            ctx.arc(x + 50, y, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        // „Ç≠„Éº„Éú„Éº„Éâ„Ç§„Éô„É≥„Éà
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                keys.left = true;
            }
            if (e.key === 'ArrowRight') {
                keys.right = true;
            }
            if (e.key === ' ' || e.key === 'Spacebar') {
                keys.space = true;
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') {
                keys.left = false;
            }
            if (e.key === 'ArrowRight') {
                keys.right = false;
            }
            if (e.key === ' ' || e.key === 'Spacebar') {
                keys.space = false;
            }
        });

        // „Çπ„Çø„Éº„ÉàÈñ¢Êï∞
        function startGame() {
            document.getElementById('titleScreen').classList.add('hidden');
            initGame();
        }

        // „É™„Çπ„Çø„Éº„ÉàÈñ¢Êï∞
        function restartGame() {
            document.getElementById('titleScreen').classList.remove('hidden');
            gameState = 'title';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('gameClear').style.display = 'none';
        }

        // „Ç≤„Éº„É†ÈñãÂßã
        gameLoop();
    </script>
</body>
</html>